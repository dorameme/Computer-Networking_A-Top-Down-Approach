### TCP 혼잡 제어 메커니즘

---

## 1. 슬로우 스타트 (Slow Start)  
TCP 연결 초기 또는 혼잡 이벤트 이후, 네트워크 대역폭을 탐색하기 위해 사용되는 초기 단계이다.  
혼잡 윈도우(\( cwnd \))를 지수적으로 증가시켜 네트워크 상태를 파악한다.

- **동작 방식**  
  - 초기값: \( cwnd = 1 \)로 시작한다.  
  - RTT마다 \( cwnd \)를 두 배로 증가시킨다.  
  - 혼잡 윈도우가 \( ssthresh \)(임계값)에 도달하면 슬로우 스타트를 종료하고 혼잡 회피로 전환한다.

- **예시**  
  - \( cwnd = 1, 2, 4, 8 \) 순으로 증가한다.  
  - \( ssthresh = 10 \)인 경우, \( cwnd = 8 \) 이후 혼잡 회피 단계로 전환된다.

---

## 2. 혼잡 회피 (Congestion Avoidance)  
네트워크 혼잡을 줄이며 대역폭을 점진적으로 활용하기 위한 단계이다.  
혼잡 윈도우를 선형적으로 증가시켜 안정성을 유지한다.

- **동작 방식**  
  - RTT마다 \( cwnd = cwnd + 1 \)로 선형적으로 증가한다.  
  - 혼잡 이벤트가 발생하면 \( cwnd \)를 감소시킨다.

- **예시**  
  - \( cwnd = 10, 11, 12, 13 \)처럼 점진적으로 증가한다.  
  - 혼잡 발생 시 \( cwnd = 6 \)으로 감소하고 다시 증가한다.

---

## 3. 빠른 회복 (Fast Recovery)  
혼잡 이벤트 발생 후, \( cwnd \)를 완전히 초기화하지 않고 절반으로 줄여 빠르게 복구하는 단계이다.  
TCP Reno에서 도입된 메커니즘이다.

- **동작 방식**  
  - 혼잡 발생 시 \( cwnd = cwnd / 2 \)로 감소.  
  - 이후 선형적으로 \( cwnd \)를 증가시킨다.

- **예시**  
  - 혼잡 발생 전 \( cwnd = 16 \).  
  - 혼잡 발생 시 \( cwnd = 8 \)로 감소하고, 이후 \( cwnd = 9, 10, 11 \) 순으로 증가한다.

---

## 4. 느린 복구 (Slow Recovery)  
혼잡 이벤트 발생 시 혼잡 윈도우를 1로 초기화하여 네트워크 상태를 처음부터 다시 탐색하는 단계이다.  
TCP Tahoe에서 사용된다.

- **동작 방식**  
  - 혼잡 발생 시 \( cwnd = 1 \)로 초기화.  
  - 슬로우 스타트 방식으로 \( cwnd \)를 지수적으로 증가시킨다.  
  - \( ssthresh \)에 도달하면 혼잡 회피로 전환된다.

- **예시**  
  - 혼잡 발생 전 \( cwnd = 16 \).  
  - 혼잡 발생 시 \( cwnd = 1 \)로 초기화되고, 이후 \( cwnd = 2, 4, 8 \)로 증가한다.

---

## 5. 메커니즘 비교 표

| **메커니즘**       | **설명**                                    | **증가 방식**     | **감소 방식**             | **특징**                                     |
|--------------------|--------------------------------------------|------------------|--------------------------|---------------------------------------------|
| **슬로우 스타트**  | 연결 초기 또는 혼잡 후 대역폭 탐색 단계.      | 지수적 증가       | 혼잡 발생 시 초기화.       | 대역폭 탐색 속도가 빠르나 혼잡 위험 존재.    |
| **혼잡 회피**      | 네트워크 혼잡을 줄이며 점진적으로 대역폭 활용. | 선형적 증가       | 혼잡 발생 시 선형 감소.    | 안정성을 중시하며 천천히 증가.               |
| **빠른 회복**      | 혼잡 후 처리량을 빠르게 회복.               | 선형적 증가       | \( cwnd \)를 절반으로 감소 | 복구가 빠르고 대역폭 활용 효율적.            |
| **느린 복구**      | 혼잡 발생 후 네트워크 상태를 재탐색.         | 지수적 증가       | \( cwnd = 1 \)로 초기화    | 안정적이지만 처리량 복구 속도가 느림.         |

---

## 결론  
1. **슬로우 스타트**는 연결 초기 네트워크 상태를 탐색하는 단계이다.  
2. **혼잡 회피**는 네트워크 안정성을 유지하며 대역폭을 점진적으로 활용한다.  
3. **빠른 회복**은 혼잡 이벤트 후 \( cwnd \)를 절반으로 줄여 성능을 빠르게 복구한다.  
4. **느린 복구**는 혼잡 이벤트 후 네트워크를 처음부터 탐색하지만, 복구 속도가 느리다.  

TCP Reno는 빠른 회복을 도입하여 TCP Tahoe보다 성능을 개선하였으며, 현대 TCP 알고리즘(CUBIC 등)은 이를 기반으로 더 높은 효율성을 달성하였다.
# TCP Reno와 CUBIC 추가 정보

![image](https://github.com/user-attachments/assets/280f69ea-7ac0-4961-9af3-95bba251d996)

## 1. TCP Reno

### 설명

TCP Reno는 **가법적 증가, 승법적 감소(AIMD / Additive Increase, Multiplicative Decrease)** 방식을 사용하는 혼잡 제어 알고리즘이다.      
네트워크에서 혼잡이 감지되면 혼잡 윈도우(Congestion Window,  cwnd ) 크기를 줄여 혼잡을 완화하고,      
이후 윈도우 크기를 점진적으로 증가시켜 네트워크 상태를 최적화한다.

### 특징

- **혼잡 윈도우 증가**: 선형 증가 방식. 
  - RTT(Round Trip Time)마다 cwnd 를 1씩 증가.
- **혼잡 감지 시 감소**: 혼잡 이벤트 발생 시  cwnd 를 절반으로 감소.
- **적합한 환경**: 일반적인 대역폭과 RTT 환경에 적합.
- **단점**: 고속 네트워크에서는 대역폭 활용이 비효율적.

### 예시

1. 초기 혼잡 윈도우  cwnd 가 1로 시작.
   - 네트워크가 안정적일 때  cwnd 는 1, 2, 3, 4와 같이 일정하게 증가.
2. 혼잡 발생 시:
   - 예를 들어, cwnd = 16 일 때 패킷 손실이 발생하면 절반인 8로 감소.
3. 다시 증가:
   - 이후  cwnd 는 다시 9, 10, 11로 선형적으로 증가.

---

## 2. TCP CUBIC

### 설명

TCP CUBIC은 고속 네트워크 환경에서의 대역폭 활용을 최적화하기 위해 설계된 혼잡 제어 알고리즘이다.      
기존 TCP Reno의 선형 증가 방식을 개선하여 3차 함수(Cubic Function)를 기반으로 혼잡 윈도우 크기를 조정한다.

### 특징

- **혼잡 윈도우 증가**: 3차 함수 기반
- **혼잡 감지 시 감소**: 혼잡 발생 시 cwnd를 약 70%로 감소.
- **적합한 환경**: 고속 네트워크 및 긴 RTT 환경에 적합.
- **슬로우 스타트 사용**: 연결 초기 및 혼잡 이후에는 슬로우 스타트를 사용하여 cwnd를 지수적으로 증가시킨다.
  - 혼잡 이벤트 이후 슬로우 스타트로 시작한 뒤 큐빅 함수 기반 혼잡 회피로 전환.
- **RTT 독립성**: RTT와 상관없이 혼잡 윈도우 증가가 시간 기반으로 이루어진다.

### 장점

- 높은 대역폭 활용.
- RTT에 독립적으로 작동하여 긴 RTT 환경에서도 성능 저하가 적다.

### 단점

- 저속 네트워크에서는 Reno와 비슷한 성능.
- 고속 네트워크가 아닌 환경에서 장점이 미미.

### 예시

1. 초기 혼잡 윈도우  cwnd 가 1로 시작.
   - 혼잡 이벤트 발생 전에는 천천히 증가하며 안정적으로 동작.
2. 혼잡 발생 시:
   -  혼잡이 발생하면 70%로 감소.
3. 복구와 더 빠른 증가:
   - 혼잡 이후 까지 느리게 증가하다가, 이후에는 급격히 증가.


---

## 3. TCP Reno vs TCP CUBIC: 비교 표

| **특징**             | **TCP Reno**                         | **TCP CUBIC**                         |
|-----------------------|---------------------------------------|---------------------------------------|
| **혼잡 윈도우 증가**  | 선형 증가 (Additive Increase)         | 3차 함수 기반 증가                    |
| **혼잡 발생 시 감소** | 혼잡 발생 시 cwnd  절반 감소    | 혼잡 발생 시 cwnd  70%로 감소   |
| **슬로우 스타트**     | 사용                                   | 사용                                   |
| **RTT 의존성**       | RTT에 민감                            | RTT 독립적                             |
| **적합한 환경**      | 일반 네트워크                         | 고속 네트워크 및 긴 RTT 환경          |
| **장점**             | 간단하고 안정적                       | 높은 대역폭 활용, 더 빠른 복구 속도   |
| **단점**             | 고속 네트워크에서 비효율적            | 저속 네트워크 환경에서 효과 제한적     |



## 3.7.3 공평성
TCP에선 두 연결이 더 공평한 대역폭을 나누는 방향(파란색 대각선)으로 이동한다.
![image](https://github.com/user-attachments/assets/5e915160-fbb0-4ea3-9ba3-c432c1f15556)

---

1. **TCP의 공정성(Fairness)**  
   - TCP는 여러 연결이 네트워크 대역폭을 공정하게 나누도록 설계되었다  
   - 혼잡 제어 알고리즘은 처리량이 불균형한 연결을 점진적으로 공정한 상태로 조정한다.

2. **AIMD 메커니즘**  
   - **가법적 증가(Additive Increase):** 네트워크가 안정적일 때 각 연결의 처리량을 선형적으로 증가시킴.  
   - **승법적 감소(Multiplicative Decrease):** 혼잡이 발생하면 각 연결의 처리량을 비율적으로 감소시켜 공정성을 유지.

3. **혼잡 윈도우 조정**  
   - 처리량이 높은 연결은 증가 속도가 억제되고, 처리량이 낮은 연결은 더 빠르게 증가하여 균형을 맞춤.  
   - 결국 모든 연결이 공평한 혼잡 윈도우 크기를 가지도록 수렴.

4. **공정성 지표 기반**  
   - TCP는 Jain's Fairness Index 등 공정성 지표를 기반으로 대역폭을 최적화.  
   - 이는 네트워크 자원을 효율적으로 활용하면서 모든 연결이 공평하게 대역폭을 나누도록 유도.

5. **네트워크 안정성 및 QoS 개선**  
   - 공정한 대역폭 분배는 네트워크의 혼잡을 줄이고 사용자 경험(QoS)을 개선.  
   - 하나의 연결이 과도한 대역폭을 독점하지 않도록 방지.

---

### 결론  
TCP 혼잡 제어 알고리즘은 **공정성**과 **효율성**을 달성하기 위해 설계되었다 
- **공정성:** 모든 연결이 대역폭을 균등하게 나누도록 조정.  
- **효율성:** 네트워크 자원의 최대 활용 보장.  
이로 인해 연결 간 대역폭 사용이 점차 공평한 상태(파란색 대각선)로 수렴

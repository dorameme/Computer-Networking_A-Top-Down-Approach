### 1. **TCP는 SR 방식에 더 가깝다?**

TCP는 **Selective Repeat (SR) 방식**에 더 가깝다.     
TCP는 개별 패킷에 대한 ACK(확인 응답)를 보내며, 손실된 패킷만 재전송한다.    
이러한 동작은 SR과 유사하며, 모든 패킷을 순서대로 재전송하는 Go-Back-N (GBN)과 다르다.

### 2. **왜 TCP는 GBN 방식처럼 보일까?**

TCP가 **GBN 방식처럼 보이는 이유**는 다음과 같다:

- TCP는 수신자가 중복 ACK를 전송하여 특정 패킷이 손실되었음을 알린다.
- 송신자는 손실된 패킷을 감지하고 빠른 재전송(Fast Retransmit)을 수행하는데, 이 과정에서 여러 패킷을 연달아 전송하는 GBN과 유사하게 보일 수 있다.
- 하지만 TCP는 SR처럼 정확히 손실된 패킷만 재전송한다.

### 3. **슬라이딩 윈도우? 이것도 SR인가? GBN?**

TCP의 슬라이딩 윈도우(Sliding Window)는 SR과 GBN의 혼합적인 동작을 가진다. 슬라이딩 윈도우 방식에서:

- TCP는 수신 윈도우(Receive Window)를 기반으로 전송할 수 있는 데이터의 양을 조절한다.
- 수신자가 ACK를 보낸 데이터만큼 송신자가 새로운 데이터를 보낼 수 있는 구조이다.
- 재전송 방식은 SR 방식에 가깝다.

### 4. 윈도우 프로브(Window Probe)

윈도우 프로브(Window Probe)는 수신 윈도우 크기가 0일 때 송신자가 수신자의 상태를 확인하기 위해 **1바이트 데이터로 세그먼트**를 전송하는 방식이다.     
이를 통해 송신자는 다음과 같은 작업을 수행한다:

- 수신자가 윈도우 크기를 다시 증가시켰는지 확인한다.
- 수신 윈도우 상태에 따라 추가 데이터를 전송할 준비가 되었는지 판단한다.

### 5. 빠른 재전송(Fast Retransmit)

빠른 재전송(Fast Retransmit)은 중복 ACK가 **3회 이상 수신**되었을 때, 타이머 만료를 기다리지 않고 손실된 것으로 간주된 패킷을 즉시 재전송하는 메커니즘이다.    
이를 통해 다음과 같은 효과를 얻는다:

- 데이터 전송 지연을 최소화한다.
- 패킷 손실 상황에서 빠르게 복구를 수행한다.
- 네트워크 혼잡을 줄이면서 효율성을 높인다.

### 6. **단일 재전송 타이머란?**

TCP는 단일 재전송 타이머(Single Retransmission Timer)를 사용한다. 각 연결당 하나의 타이머만 사용하여 특정 패킷에 대한 ACK가 지정된 시간 안에 수신되지 않을 경우, 해당 패킷을 재전송한다. 이 방식은 타이머 오버헤드를 줄이면서도 효율적인 재전송을 가능하게 한다.

### 7. 피기백(Piggyback)?

피기백(Piggyback)은 데이터 프레임에 **ACK 응답**을 함께 실어서 보내는 기술이다.    
송신자가 데이터를 전송할 때 수신자가 데이터에 대한 응답(ACK)을 별도로 보내지 않고, 데이터 프레임에 피기백된 ACK를 포함해 전송함으로써 네트워크 효율을 높인다.       
TCP는 이러한 피기백 방식을 지원한다.
### **피기백(Piggyback) 개념**

**피기백(Piggyback)**은 네트워크 통신에서 데이터 프레임에 ACK(응답)을 함께 실어 보내는 기술이다.  
이는 별도의 ACK 패킷을 전송하지 않고 데이터 전송 과정에서 ACK를 포함시킴으로써 **네트워크 효율을 향상**시키는 방법이다.

---

### **동작 원리**
1. **송신자**:
   - 데이터를 수신자에게 전송.
2. **수신자**:
   - 데이터를 처리한 후, ACK 응답을 보내야 할 때 별도의 ACK 패킷을 생성하지 않고 **다음 데이터 프레임에 ACK 정보를 포함**하여 송신자에게 전송.

---

### **장점**
1. **네트워크 효율 향상**:
   - 별도의 ACK 패킷을 전송하지 않아 **대역폭 사용량**을 줄임.
2. **지연 감소**:
   - 데이터와 ACK가 동시에 전송되어 **통신 지연**이 줄어듦.
3. **패킷 수 감소**:
   - 별도의 ACK 패킷이 필요 없으므로 **패킷 전송량이 감소**.

---

### **단점**
1. **타이밍 의존**:
   - 피기백이 가능하려면 응답을 포함한 데이터 프레임이 생성될 때까지 기다려야 하므로 **응답 지연**이 발생할 수 있음.
2. **비대칭 트래픽**:
   - 송신자와 수신자 간 데이터 흐름이 불균형할 경우, 피기백의 효과가 제한적.
   - 예: 수신자가 송신자에게 데이터를 전송할 일이 없을 경우 별도의 ACK 전송이 필요.

---

### **예시**
- **기본 ACK 방식**:
  - 송신자가 데이터를 전송하면, 수신자는 별도의 ACK 패킷을 생성해 송신자에게 응답을 보냄.
  - 데이터: `[데이터1]` → 송신자 → 수신자
  - ACK: `[ACK for 데이터1]` → 수신자 → 송신자

- **피기백 방식**:
  - 수신자가 송신자에게 데이터를 전송할 때, 해당 데이터 프레임에 ACK 정보를 포함하여 응답.
  - 데이터: `[데이터1]` → 송신자 → 수신자
  - 데이터+ACK: `[데이터2 + ACK for 데이터1]` → 수신자 → 송신자

---

### **요약**
- 피기백(Piggyback)은 데이터를 전송할 때 ACK 응답을 데이터 프레임에 포함하여 네트워크 효율을 높이는 기술이다.
- **장점**으로는 대역폭 절약, 패킷 수 감소 등이 있으며, **단점**으로는 응답 지연과 비대칭 트래픽에서의 한계가 있다.
- **효율적인 네트워크 설계**에서 피기백은 통신 효율을 높이는 중요한 기법으로 사용된다.
  
### 8. **GBN, SR, TCP 비교표**

| 항목            | **GBN**          | **SR**        | **TCP**         |
| ------------- | ---------------- | ------------- | --------------- |
| **ACK 처리 방식** | 누적 ACK           | 개별 패킷에 대한 ACK | 개별 ACK 및 중복 ACK |
| **재전송 방식**    | 손실된 패킷 이후 모두 재전송 | 손실된 패킷만 재전송   | 손실된 패킷만 재전송     |
| **윈도우 관리**    | 고정 윈도우 크기        | 고정 또는 유동적 윈도우 | 동적 윈도우 크기 조정    |
| **효율성**       | 상대적으로 낮음         | 높음            | 중간에서 높음         |

### 9. **TCP 명세서에서 수신 윈도가 0일 때 1바이트 데이터 전송을 요구하는 이유**

TCP 명세서는 수신 윈도우가 0일 때에도 송신자가 **1바이트 데이터로 세그먼트**를 계속 전송하도록 요구한다. 그 이유는 다음과 같다:

- 수신자가 윈도우 크기를 다시 증가시키는 시점을 송신자가 알기 어렵기 때문에, 윈도우 프로브(Window Probe)로 1바이트 데이터를 전송해 수신 윈도우 상태를 확인한다.
- 이를 통해 송신자는 수신자가 언제 데이터를 수신할 준비가 되었는지 알 수 있다.

### 10. SYN 플러드(SYN Flood)

SYN 플러드(SYN Flood)는 DoS(Distributed Denial-of-Service) 공격의 일종으로, 대량의 SYN 패킷을 서버에 전송해 서버가 반연결 상태(Half-Open Connection)에 머무르도록 만든다.

#### SYN 플러드 공격의 원리
SYN 플러드 공격은 다음과 같은 과정으로 서버 자원을 소모시킨다:

1. **클라이언트 → 서버: 다량의 SYN 요청**
   - 공격자는 정상적인 클라이언트처럼 보이도록 위조된 IP 주소를 사용하거나, 대량의 SYN 패킷을 서버로 보낸다.

2. **서버 → 클라이언트: SYN-ACK 응답**
   - 서버는 각 SYN 요청에 대해 응답(SYN-ACK)을 보낸다.
   - 동시에 각 요청마다 연결 상태 정보를 저장하고 자원을 할당한다.

3. **클라이언트 → 서버: ACK 없음**
   - 공격자는 고의적으로 마지막 ACK를 보내지 않는다.
   - 서버는 연결 완료를 기다리며 자원을 유지한다.

4. **자원 고갈**
   - 서버는 일정 시간 동안(일반적으로 1분 이상) 연결 대기 상태를 유지한다.
   - 새로운 SYN 요청이 계속 들어오면 서버의 메모리와 CPU가 과부하 상태가 된다.
   - 결국 서버는 정상적인 클라이언트 요청을 처리할 수 없게 된다.

#### SYN 플러드 공격의 핵심 문제점

1. **자원 낭비**
   - 서버는 각 SYN 요청에 대해 자원을 할당하고 대기해야 한다.
   - 정상적인 요청을 위한 자원이 부족해진다.

2. **대기 시간 증가**
   - 서버는 클라이언트의 ACK 응답을 기다리며 타임아웃(timeout)이 발생하기 전까지 자원을 유지한다.
   - 이 시간 동안 서버는 불필요하게 많은 연결 상태를 관리해야 한다.

3. 연결 대기열(Backlog Queue) 초과
   - 서버는 연결 요청을 처리하기 위해 Backlog Queue를 유지한다.
   - 공격자가 다량의 SYN 요청을 보내면 이 대기열이 초과되어 새로운 요청을 받지 못한다.

#### SYN 플러드 공격 방어 방법

1. SYN 쿠키(SYN Cookie) 사용
   - 서버가 SYN 요청을 받았을 때 자원을 할당하지 않고, SYN-ACK 패킷에 특별한 쿠키를 포함하여 클라이언트로 보낸다.
   - 클라이언트가 ACK를 보낼 때 쿠키를 반환해야만 서버가 연결을 확정한다.
   - 이를 통해 자원을 최소화하고 공격을 방어한다.

2. **타임아웃 값 줄이기**
   - 연결 대기 상태를 유지하는 시간을 줄여 자원 소모를 줄인다.

3. **IP 필터링 및 제한**
   - 공격자로 의심되는 IP에서의 연결 요청을 차단하거나, 특정 IP당 연결 요청 수를 제한한다.

4. **방화벽 및 DDoS 방어 솔루션**
   - 고급 방화벽과 DDoS 방어 솔루션을 사용하여 의심스러운 트래픽을 차단한다.

5. **분산된 서버 배치**
   - 트래픽을 여러 서버로 분산시켜 한 서버가 과부하되지 않도록 설계한다.


# 8.6 TCP 연결의 보안: TLS
![image](https://github.com/user-attachments/assets/64b76815-edee-4c81-b959-2af533327782)


보안 서비스가 추가되어 향상된 TCP 버전을 흔히 **TLS(Transport Layer Security)** 라고 부른다.&#x20;

TLS는 기밀성, 데이터 무결성, 서버 인증과 클라이언트 인증을 통해 TCP를 강화하여 보안 서비스를 제공한다.&#x20;

TLS는 TCP 상에서 동작하므로, TCP를 사용하는 모든 애플리케이션에서 사용할 수 있다.

---

## TLS란?

- **TLS의 역할:** 애플리케이션 계층에서 동작하며, 보안 서비스로 강화된 TCP 서비스를 제공한다.
- **주요 특징:**
  - 기밀성: 데이터를 암호화하여 제3자가 내용을 읽을 수 없도록 보호한다.
  - 데이터 무결성: 데이터가 변조되지 않았음을 보장한다.
  - 서버 및 클라이언트 인증: 서로의 신원을 확인한다.
- **개발자 관점:** TLS는 TCP와 유사한 간단한 API를 제공하여 사용하기 쉽다.

### TLS 작동 방식

TLS는 세 가지 주요 단계로 동작한다:

1. **핸드셰이크 (Handshake):** 서버와 클라이언트 간에 보안을 설정하는 단계이다.
2. **키 유도 (Key Derivation):** 안전한 데이터 전송을 위해 대칭키와 인증키를 생성한다.
3. **데이터 전송 (Data Transmission):** 데이터를 암호화 및 인증하여 안전하게 전송한다.

---

## 8.6.1 TLS 개요: almost TLS

TLS의 개념을 이해하기 위해 단순화된 버전인 **almost-TLS**를 먼저 살펴본다.

### 1. 핸드셰이크 (Handshake)

**핸드셰이크 단계에서 서버와 클라이언트는 보안을 설정한다.**

1. **TCP 연결 설정:** 클라이언트가 서버와 TCP 연결을 수립한다.
2. **서버 인증:** 서버는 CA로부터 인증된 인증서를 클라이언트에게 전달한다.
   - 클라이언트는 인증서를 확인하고, 인증서 내 공개키가 서버의 것임을 신뢰한다.
3. **주 비밀키(Master Secret, MS) 생성:**
   - 클라이언트와 서버는 TLS 세션에 필요한 MS를 생성한다.
   - 클라이언트는 MS를 서버의 공개키로 암호화(EMS)하여 서버에 전달한다.
   - 서버는 자신의 개인키로 EMS를 복호화해 MS를 얻는다.
4. **결과:** 클라이언트와 서버는 MS라는 공통 비밀값을 공유하게 된다.

요약:&#x20;

핸드셰이크로 TCP 연결을 수립 ➡️ \
서버가 공개키(비대칭키)로 암호화된 인증서를 전달 ➡️ \
클라이언트와 서버가 각각 대칭키(MS의 일부)를 생성 ➡️ \
클라이언트가 MS를 서버의 공개키로 암호화해 전달 ➡️ \
서버는 본인의 개인키로 복호화하여 MS를 얻음 ➡️ \
결과적으로 클라이언트와 서버가 동일한 MS를 공유하게 됨. 

### 2. 키 유도 (Key Derivation)

MS를 바탕으로 데이터 암호화와 무결성 검사를 위한 4개의 키를 생성한다:

- MS를 통해 **4개의 키**를 유도한다:
  1. E(b): 클라이언트 → 서버 데이터 암호화 키
  2. M(b): 클라이언트 → 서버 HMAC(에이치맥: 무결성 검사용) 키
  3. E(a): 서버 → 클라이언트 데이터 암호화 키
  4. M(a): 서버 → 클라이언트 HMAC 키

**결과:**

- 2개의 암호화 키로 데이터를 암호화한다.
- 2개의 HMAC 키로 데이터 무결성을 확인한다.

**비유:**

- MS를 바탕으로 서로 다른 열쇠 4개를 만들어 각 방향의 데이터를 보호한다.

### 3. 데이터 전송 (Data Transmission)

TLS는 데이터를 안전하게 암호화하고 인증하며 TCP로 전송한다:

1. **데이터 암호화:**
   - 클라이언트는 데이터 레코드를 생성하고, 암호화 키(E(b))를 사용해 데이터를 암호화한다.
2. **HMAC 추가:**
   - 데이터 레코드에 HMAC 키(M(b))를 사용하여 무결성 검사를 위한 HMAC을 추가한다.
3. **레코드 전송:**
   - 암호화된 레코드+HMAC 꾸러미를 TCP로 전송한다.

### **순서 번호의 역할**

순서 번호는 TLS에서 데이터 전송 시 **무결성과 정렬 보장**을 위해 중요한 역할을 한다.

1. **무결성 확인:**

   - 각 레코드마다 순서 번호를 포함하여 HMAC을 계산한다. 이를 통해 데이터가 중간에 변조되었는지 확인할 수 있다.

2. **정렬 보장:**

   - 클라이언트와 서버는 각 레코드의 순서 번호를 추적하여 올바른 순서대로 데이터를 복원한다.
   - 침입자가 데이터 순서를 바꾸거나 삭제하려는 시도를 방지한다.


### **침입자가 순서를 알고 있는 경우**
침입자가 순서 번호를 알고 있더라도, 다음 이유로 데이터를 변조하는 것이 어렵다:
1. **HMAC 키를 알 수 없음:**  
   - HMAC 값은 `M(b)` 키를 사용해 생성되며, 침입자는 이 키를 알 수 없다.  
   - 따라서, 데이터를 조작하거나 순서를 변경하더라도 올바른 HMAC 값을 계산할 수 없다.

2. **순서 번호 + 데이터의 조합:**  
   - HMAC은 순서 번호와 데이터를 함께 사용하여 계산되므로, 데이터를 조작하거나 순서를 바꾸면 HMAC 검증에 실패한다.

3. **종단 간 검증:**  
   - 종단 간 검증은 순서 번호를 포함한 TLS의 전체적인 보안 메커니즘을 의미하며, 순서 번호는 그중 하나의 핵심 도구로 작용한다.
   - TLS는 클라이언트와 서버 간의 종단(end-to-end) 암호화와 인증을 제공하므로, 중간에 데이터가 변경되었는지 확실히 검증할 수 있다.
---

### **결론**
TLS에서 순서 번호는 데이터 무결성을 강화하는 핵심 요소이다. 침입자가 순서 번호를 안다고 하더라도, HMAC 키를 모르는 이상 데이터 변조나 순서 변경을 통해 TLS 보안을 무력화할 수 없다. 

---

## 8.6.2 TLS의 완전한 개념

### TLS 핸드셰이크

TLS는 암호화 알고리즘 선택, 키 교환, 인증을 포함한 완전한 핸드셰이크를 수행한다:

1. **암호화 알고리즘 선택:**
   - 클라이언트는 지원 가능한 암호화 알고리즘 목록과 넌스를 서버에 보낸다.
2. **넌스:**
   - 넌스는 모든 메시지의 유일성을 보장하여 재사용 공격을 방지한다.
3. **서버 응답:**
   - 서버는 암호화 알고리즘을 선택하고, 인증서와 넌스를 클라이언트에 보낸다.
4. **PMS(Pre-Master-Secret) 생성:**
   - 클라이언트는 PMS를 생성하고 서버의 공개키로 암호화하여 서버에 전송한다.
   - 서버는 자신의 개인키로 PMS를 복호화한다.
5. **MS 계산 및 키 유도:**
   - 클라이언트와 서버는 같은 키 유도 함수를 사용하여 PMS와 넌스에서 MS를 계산한다.
   - MS는 이후 4개의 키로 분할되어 데이터 암호화와 인증에 사용된다.

### **TLS 종료 레코드:**

단순히 TCP FIN 세그먼트를 사용하면 침입자가 절단 공격을 할 수 있으므로, TLS는 종료 메시지를 암호화된 레코드로 전송한다.

---

## TLS의 요약

- **핸드셰이크:** 클라이언트와 서버가 안전하게 MS를 공유하고, 암호화 알고리즘을 합의한다.
- **키 유도:** MS를 바탕으로 암호화 키와 인증 키를 생성한다.
- **데이터 전송:** 데이터를 암호화하고 HMAC으로 인증하여 안전하게 전달한다.
- **순서 번호:** 데이터를 정렬하고 변조를 방지하기 위해 사용된다.
- **종료:** 침입자 공격을 방지하며 TLS 세션을 안전하게 종료한다.

---

## TLS와 almost-TLS 비교

| **구분**          | **TLS**                                                       | **almost-TLS**                            |
| --------------- | ------------------------------------------------------------- | ----------------------------------------- |
| **핸드셰이크**       | 클라이언트와 서버가 암호화 알고리즘, 넌스, 인증서를 교환하여 MS를 생성한다.                  | 클라이언트와 서버가 TCP 연결 후 인증서를 교환하고 MS를 생성한다.   |
| **키 유도**        | MS를 바탕으로 키 유도 함수를 사용해 4개의 세션 키(E(b), M(b), E(a), M(a))를 생성한다. | MS를 이용해 단순히 4개의 키를 분리하여 생성한다.             |
| **데이터 암호화**     | 데이터 레코드에 HMAC을 추가하고 암호화하여 TCP로 전송한다.                          | 데이터 레코드에 HMAC을 추가하고 암호화한 뒤 TCP로 전송한다.     |
| **무결성 확인**      | 순서 번호를 포함한 HMAC 검사를 통해 데이터의 순서와 무결성을 확인한다.                    | HMAC을 사용해 데이터 무결성을 확인하나, 순서 번호 기반 검증은 없다. |
| **암호화 알고리즘 협의** | 핸드셰이크 과정에서 클라이언트와 서버가 지원하는 암호화 알고리즘 목록 중에서 선택한다.              | 특정 알고리즘으로 고정되며 핸드셰이크 과정에서 협의하지 않는다.       |
| **적용 범위**       | 실제 환경에서 사용되는 TLS 프로토콜로, 현재 인터넷 보안의 표준으로 자리 잡고 있다.             | TLS를 이해하기 위한 단순화된 개념으로, 실무 환경에는 사용되지 않는다. |
| **보안 수준**       | 암호화 알고리즘 협상, 넌스 사용, 순서 번호 기반 검증 등으로 높은 보안을 제공한다.              | TLS보다 단순한 구조로 인해 보안 수준이 낮다.               |

---
### 추가 : 알고리즘 협상?
TLS 핸드셰이크 과정에서 사용 가능한 암호화 알고리즘은 다음과 같은 주요 범주로 나뉜다:

---

### **암호화 알고리즘의 범주**
1. **대칭키 암호화 알고리즘 (기밀성 제공)**:
   - 데이터 전송을 암호화하는 데 사용된다.
   - 주로 사용되는 대칭키 암호화 알고리즘:
     - **AES (Advanced Encryption Standard)**:
       - 128, 192, 256비트 키를 지원하며, 현재 가장 널리 사용된다.
     - **ChaCha20**:
       - 경량 암호화 알고리즘으로, 모바일 환경에서 주로 사용된다.
     - **3DES (Triple Data Encryption Standard)**:
       - 이전에 사용되던 알고리즘이지만, 현재는 더 안전한 AES로 대체되는 추세이다.

2. **비대칭키 암호화 알고리즘 (키 교환 및 인증)**:
   - 클라이언트와 서버가 비밀키를 안전하게 교환하는 데 사용된다.
   - 주로 사용되는 비대칭키 암호화 알고리즘:
     - **RSA (Rivest–Shamir–Adleman)**:
       - 가장 일반적인 키 교환 알고리즘 중 하나로, 공개키와 개인키를 사용한다.
     - **ECDHE (Elliptic Curve Diffie-Hellman Ephemeral)**:
       - 키 교환 시 높은 보안성과 효율성을 제공하며, RSA를 대체하는 추세이다.
     - **DH (Diffie-Hellman)**:
       - 키 교환에 사용되지만, 현재는 ECDHE가 더 선호된다.

3. **HMAC 알고리즘 (무결성 제공)**:
   - 데이터의 무결성을 확인하는 데 사용된다.
   - 주로 사용되는 HMAC 알고리즘:
     - **HMAC-SHA256**:
       - 안정성과 성능이 우수하며 널리 사용된다.
     - **HMAC-SHA384**:
       - SHA-256보다 강력한 보안을 제공한다.
     - **HMAC-SHA1**:
       - 과거에 널리 사용되었으나, 보안 취약성 때문에 현재는 덜 사용된다.

4. **난수 생성 (넌스 포함)**:
   - 핸드셰이크 중 클라이언트와 서버가 고유성을 유지하고, 재사용 공격을 방지하기 위해 사용하는 알고리즘:
     - **PRNG (Pseudo Random Number Generator)**:
       - 고품질 난수를 생성하는 데 사용된다.

---

### **암호화 알고리즘 협의 과정**
1. **클라이언트 제안**:
   - 클라이언트는 자신이 지원하는 암호화 알고리즘 목록을 서버에 전송한다.
   - 예: `AES256-GCM-SHA384`, `ECDHE-RSA-AES128-GCM-SHA256`

2. **서버 선택**:
   - 서버는 클라이언트의 제안 목록 중에서 자신도 지원하는 가장 강력한 암호화 알고리즘을 선택한다.

3. **결정된 암호화 알고리즘**:
   - 서버는 선택한 암호화 알고리즘을 클라이언트에 알리고, 이후 세션에서 이를 사용한다.

---

### **결론**
TLS 핸드셰이크 과정에서는 클라이언트와 서버가 함께 사용할 수 있는 암호화 알고리즘을 협상하여 선택한다.        
이 알고리즘은 기밀성(AES), 인증(ECDHE), 무결성(HMAC-SHA256)을 포함하며,       
 최신 TLS 구현에서는 보안성과 성능을 극대화하기 위해 AES(데이터암호화), ECDHE(인증), HMAC-SHA256(무결성) 등의 알고리즘을 선호한다. 

---

### 추가 : AES ? RSA ?
### AES(대칭키 암호화:암호화와 복호화에 같은 키를 사용한다)
데이터를 암호화/복호화하는 데 사용된다.        
암호화와 복호화에 같은 키를 사용하므로 빠르고 효율적이다.      
TLS에서는 클라이언트와 서버가 공유한 세션키(MS를 통해 생성된 대칭키)로 데이터를 암호화한다.

### RSA/ECDHE(공개키 암호화: 암호화와 복호화에 다른 키를 사용한다)      
공개키(Public Key): 암호화에 사용. 누구에게나 공개 가능.     
개인키(Private Key): 복호화에 사용. 소유자만 알고 있어야 한다.      

클라이언트와 서버 간 세션키를 안전하게 교환하는 데 사용된다.      
공개키로 암호화된 데이터를 개인키로 복호화할 수 있어, 비대칭적이다.       
TLS 핸드셰이크 단계에서 서버의 공개키로 클라이언트가 생성한 비밀값(PMS)을 암호화해 전송하고, 서버는 개인키로 이를 복호화해 세션키(MS)를 얻는다.

![Image](https://github.com/user-attachments/assets/9fd00136-7b4b-46f2-a642-6e703d46a60b)

### 6.2 오류 검출 및 정정 기술

#### 오류 검출의 개념

비트 오류를 방지하기 위해 송신 노드는 데이터(D)에 오류 검출 및 정정 비트들(EDC)를 첨가한다. 송신된 데이터 D와 EDC는 전송 도중 변경될 가능성이 있다. 따라서 수신자는 데이터가 변경되었는지 확인하기 위해 오류 검출 여부를 판단해야 한다.

오류 검출 및 정정 기술을 사용하더라도 여전히 미검출된 비트 오류(undetected bit error)가 발생할 수 있다. 즉, 수신자가 잘못된 데이터를 네트워크 계층으로 전달하거나, 프레임 헤더의 잘못된 내용을 인지하지 못할 가능성이 있다. 따라서 오류 검출의 신뢰도를 높이기 위해 오류를 감지하지 못할 확률이 낮은 기법을 선택해야 한다. 일반적으로 오류 검출 확률이 낮을수록 오버헤드는 커진다.

---

### 6.2.1 패리티 검사(여기선 EDC가 패리티)

#### 단일 패리티 비트
![Image](https://github.com/user-attachments/assets/a2156f18-3717-4d2f-be00-f08a700c90e7)
##### 개념

데이터 D가 d개의 비트를 갖고 있다고 가정한다. 짝수 패리티 기법에서는 D에 하나의 패리티 비트를 추가하여 d+1개의 비트에서 1의 총 개수가 짝수가 되도록 설정한다. 홀수 패리티 기법에서는 1의 총 개수가 홀수가 되도록 패리티 비트를 설정한다.

##### 동작 원리

- 송신자는 데이터 D에 패리티 비트를 추가하여 전송한다.
- 수신자는 수신된 d+1개의 비트에서 1의 개수를 계산하여 짝수 또는 홀수 패리티 조건을 만족하는지 확인한다.

##### 장단점

- 장점: 간단하고 구현이 쉽다.
- 단점: 홀수 개의 비트 오류는 검출 가능하지만, 짝수 개의 비트 오류는 검출할 수 없다.

##### 예시

원래 데이터: `1011`\
짝수 패리티 비트 추가: `10111` (1의 개수가 짝수가 됨)\
수신 데이터: `10110` (1의 개수가 홀수로 오류 검출 가능)

### 왜 홀수 개의 비트 오류만 검출할 수 있는가?   
- 패리티 검사는 전체 비트 중 1의 개수가 짝수인지 홀수인지로 오류를 검출한다.    
 따라서, 1개의 비트가 반전되면 1의 개수가 홀수에서 짝수로, 또는 짝수에서 홀수로 바뀌므로 오류가 검출된다.    
그러나, 2개의 비트가 반전되면 1의 개수가 다시 원래 상태로 복구되기 때문에 오류를 검출할 수 없다.    

### 왜 50% 확률로 오류를 검출할 수 있는가?
- 비트 오류가 버스트 오류로 연속적으로 발생할 경우,     
반전된 비트의 개수가 짝수인지 홀수인지에 따라 검출 가능 여부가 결정된다. 짝수와 홀수의 발생 확률이 같으므로,    
패리티 검사는 약 50% 확률로 오류를 검출할 수 있다.     


---

#### 2차원 패리티
![Image](https://github.com/user-attachments/assets/6f962985-1fec-4eff-b6ed-b70db29d0f2f)
##### 개념

2차원 패리티는 데이터를 i개의 행과 j개의 열로 나누고, 각 행과 열에 대해 패리티 비트를 계산하여 추가하는 방식이다. 이 기법은 단일 패리티 비트의 한계를 극복하며, 단일 비트 오류는 검출 및 정정이 가능하고, 임의의 두 비트 오류는 검출할 수 있다.

##### 동작 원리

1. 데이터를 행(row)과 열(column)로 나누어 2차원 배열로 배치한다.
2. 각 행과 열에 대해 패리티 비트를 계산하여 추가한다.
3. 전송된 데이터가 수신되면, 수신자는 행과 열의 패리티를 확인하여 오류를 검출하고 수정한다.

##### 예시

###### 전송 전 데이터:

```
1 0 1 1 | 1  (짝수 패리티 비트)
0 1 0 0 | 1
1 1 1 0 | 1
0 0 1 1 | 0
---------
1 0 1 0 | 0  (열 패리티 비트)
```

###### 전송 중 오류 발생:

예: 2번째 행의 첫 번째 비트가 0에서 1로 변경됨.

```
1 0 1 1 | 1
1 1 0 0 | 1  <- 오류 발생
1 1 1 0 | 1
0 0 1 1 | 0
---------
1 0 1 0 | 0
```

###### 오류 검출 및 정정:

- 2번째 행의 패리티와 1번째 열의 패리티가 맞지 않음을 확인.
- 오류 위치: 2번째 행, 1번째 열.
- 오류 정정: 해당 비트를 반전하여 수정.

##### 장단점

- 장점: 단일 비트 오류는 검출 및 정정이 가능하다. 두 비트 오류는 검출할 수 있다.
- 단점: 3개 이상의 비트 오류가 발생할 경우 정확한 검출이 어려울 수 있다.

---

### 순방향 오류 정정 (FEC: Forward Error Correction)
![Image](https://github.com/user-attachments/assets/f171488d-9fec-4413-b649-cb32743e6e58)
### 순방향 오류 정정(Forward Error Correction, FEC)

순방향 오류 정정(FEC)이란 수신자가 데이터를 수신하는 과정에서 발생할 수 있는 오류를 스스로 검출 및 정정할 수 있는 기술을 말한다. FEC는 데이터를 전송하는 송신자와 데이터를 수신하는 수신자 간의 효율적인 통신을 가능하게 한다. 

FEC 기술의 주요 목적은 송신자가 데이터를 재전송해야 하는 필요성을 줄이는 것이다. 이로 인해 다음과 같은 이점이 있다:

1. 재전송 감소: FEC는 송신자가 데이터를 재전송하는 상황을 최소화하여 네트워크 부하를 줄인다.
2. 왕복 지연 시간 제거: 일반적인 재전송 방식에서는 NAK(Negative Acknowledgment) 패킷을 통해 송신자가 데이터의 오류를 인지한 후 다시 데이터를 전송해야 한다. 하지만 FEC를 활용하면 왕복 지연 시간을 기다리지 않아도 된다.
3. 신뢰성 향상: 네트워크 상태가 불안정하거나 대역폭이 제한된 환경에서도 높은 신뢰도로 데이터를 전송할 수 있다.

FEC는 에러 정정 코드를 사용하여 구현된다. 에러 정정 코드는 송신자가 전송 데이터에 추가적인 패리티 비트나 체크 비트를 첨가함으로써 수신자가 손실되거나 손상된 데이터를 복구할 수 있도록 한다.

### 해밍 코드(Hamming Code)

해밍 코드는 가장 널리 알려진 FEC 기술 중 하나로, 한 비트 오류를 검출하고 정정할 수 있는 능력을 제공한다. 해밍 코드는 다음과 같은 절차로 동작한다:

1. 패리티 비트 삽입: 송신자는 데이터 비트에 패리티 비트를 추가한다. 패리티 비트는 데이터를 그룹으로 나누고 각 그룹의 비트 합을 계산하여 오류를 검출할 수 있도록 설계된다.

2. 오류 검출: 수신자는 데이터와 패리티 비트를 함께 읽고, 미리 설정된 패리티 계산 규칙에 따라 오류 여부를 확인한다.

3. 오류 정정: 오류가 검출되면 수신자는 패리티 비트를 활용해 정확히 어떤 비트에 오류가 있는지 찾아내고 이를 교정한다.

### 해밍 코드 더 쉽게 이해하기

해밍 코드는 데이터 비트에 추가적인 비트(패리티 비트)를 붙여 오류를 검출하고 수정하는 방법이다. 다음은 간단한 예시이다:

송신자 측 작업:
1. 데이터 비트가 `1011`이라고 가정한다.
2. 이 데이터를 해밍 코드 방식으로 확장한다:
   - 데이터 비트: `1011`
   - 추가된 패리티 비트와 함께 새로운 데이터 형식: `p1 p2 d1 p3 d2 d3 d4`
     - 여기서 p1, p2, p3는 패리티 비트이고, d1, d2, d3, d4는 원래 데이터 비트이다.
   - 각 패리티 비트를 계산하여 값이 정해진다. 예를 들어:
     - p1 = d1 XOR d2 XOR d4
     - p2 = d1 XOR d3 XOR d4
     - p3 = d2 XOR d3 XOR d4
3. 최종 전송 데이터는 `0111011`이 된다.

수신자 측 작업:
1. 데이터 `0111011`을 수신한다.
2. 각 패리티 비트를 검사하여 오류 여부를 확인한다.
3. 만약 오류가 발견되면 오류가 발생한 위치를 계산한다.
4. 오류 비트를 뒤집어서 원래 데이터를 복원한다.

### 비유를 통한 이해

해밍 코드를 쉽게 이해하기 위해 편지 봉투에 비유해보자:
1. 송신자가 편지를 작성한 뒤, 각 줄마다 총 글자 수를 적어놓는다(패리티 비트 계산).
2. 수신자는 편지를 읽을 때 각 줄의 글자 수를 확인한다.
3. 만약 글자 수가 맞지 않으면, 그 줄에서 어떤 글자가 잘못되었는지 확인하고 수정한다.

즉, 패리티 비트는 데이터를 "감시"하는 역할을 하고, 수신자가 오류를 발견했을 때 이를 "스스로 고치는" 도구를 제공한다.

### FEC와 해밍 코드의 활용

FEC와 해밍 코드는 다음과 같은 환경에서 유용하다:

1. 위성 통신: 재전송이 어려운 장거리 통신에서 FEC는 데이터를 신뢰성 있게 전달한다.
2. 네트워크 스트리밍: 실시간 데이터 전송 중 재전송 지연을 피하기 위해 사용된다.
3. 무선 통신: 간섭이 잦은 무선 환경에서도 오류 복구를 통해 데이터의 신뢰성을 높인다.

이처럼 FEC 기술은 데이터 전송의 신뢰성을 강화하고, 효율성을 높이는 데 중요한 역할을 한다. 특히 해밍 코드는 간단한 구현 방식과 실용성으로 인해 다양한 시스템에서 널리 활용되고 있다.


### 해밍 코드와 패리티 코드

해밍 코드(Hamming Code)와 패리티 코드(Parity Code)는 체크섬 또는 CRC와는 다른 오류 검출 및 수정 방법이다. 이 두 가지 방법은 주로 데이터 무결성을 유지하기 위한 별도의 기술로 사용된다.

#### 해밍 코드
- 특징: 데이터 내에 추가 비트를 삽입하여 오류를 검출하고 수정하는 기능을 제공한다.
- 원리: 데이터 비트와 오류 검출 비트를 조합하여 특정 위치의 오류를 계산하고 수정할 수 있다.
- 사용 사례: 단일 비트 오류를 수정하거나 다중 비트 오류를 검출하는 상황에서 주로 사용된다.
- 체크섬 또는 CRC와의 관계: 해밍 코드는 주로 데이터 복구를 목적으로 하며, 체크섬이나 CRC와는 다르게 오류를 수정할 수 있다.

### 해밍 코드의 오류 검출 및 수정 능력
1. 단일 비트 오류(Single-bit error):
   - 데이터 전송 중 1개의 비트가 잘못되었을 경우, 해밍 코드는 그 위치를 정확히 찾아 수정할 수 있다.
   - 추가된 패리티 비트를 통해 오류가 발생한 위치를 계산하여 해당 비트를 수정하면 데이터 복구가 가능.

2. 2비트 오류(Double-bit error):
   - 해밍 코드는 2개의 비트가 동시에 오류가 발생한 경우, 이를 검출할 수는 있지만, 수정은 불가능. 2비트 오류는 단일 비트 오류로 오인될 가능성이 있기 때문.

3. 3비트 이상의 오류(Multi-bit error):
   - 해밍 코드는 3비트 이상의 오류를 검출하거나 수정할 수 없다.

---


#### 패리티 코드
- 특징: 데이터의 비트 합이 짝수 또는 홀수인지 확인하는 간단한 오류 검출 방법이다.
- 원리: 데이터 비트의 합이 짝수(짝수 패리티) 또는 홀수(홀수 패리티)인지 계산하여 오류를 검출한다.
- 사용 사례: 간단한 오류 검출이 필요한 시스템에서 사용된다.
- 체크섬 또는 CRC와의 관계: 패리티 코드는 체크섬의 간단한 형태로 볼 수 있으며, 복잡한 연산이 필요한 CRC보다는 단순한 환경에 적합하다.


---

### 요약

- 단일 패리티 비트: 간단한 오류 검출 방식. 짝수 개의 오류는 검출 불가.
- 2차원 패리티: 단일 비트 오류는 검출 및 정정 가능. 두 비트 오류는 검출 가능.
- FEC: 수신자가 자체적으로 오류를 정정하여 네트워크 지연을 줄이는 기법.

오류 검출 및 정정 기법의 선택은 데이터의 신뢰성과 네트워크 성능 요구 사항에 따라 달라진다. 각 기법의 장단점을 이해하고 적절한 기술을 적용해야 한다.


### 6.2.2 체크섬 방법

체크섬은 데이터를 일정 비트 단위로 나누어 합산한 결과를 사용하여 오류를 검출하는 간단한 방법이다. 이 방법에서는 데이터의 d 비트들을 k 비트 정수처럼 처리하며, 이 k 비트 정수들을 모두 더한 뒤 생성된 값을 오류 검출 비트로 사용한다.

#### 체크섬 동작 과정
1. 인터넷 체크섬(Internet checksum):
   - 데이터의 k 비트 단위 합을 계산한 후, 결과값의 1의 보수를 취한다.
   - 이 1의 보수를 세그먼트 헤더에 포함시킨다.
2. 수신자 측:
   - 수신된 데이터의 합을 계산한 후, 결과값의 1의 보수를 취한다.
   - 계산 결과가 모두 1인 비트로 구성되어 있는지 확인하여 데이터의 무결성을 검증한다.

#### 체크섬의 특징
- 장점: 체크섬 방법은 상대적으로 패킷 오버헤드가 적어 TCP와 UDP에서 사용된다.
- 단점: 순환 중복 검사(CRC)에 비해 오류 검출 능력이 떨어진다.

#### TCP와 UDP에서 사용하는 이유
- TCP와 UDP는 소프트웨어로 구현되기 때문에 간단하고 빠른 오류 검출 기법이 필요하다.
- 반면, 링크 계층은 네트워크 어댑터 안에 하드웨어로 구현되어 더 복잡하지만 정확도가 높은 CRC를 사용한다.

#### 체크섬과 CRC의 차이
- 체크섬: 데이터 전체에서 문제가 발생했는지 확인하는 간단한 방식이다. 예를 들어, 장바구니의 모든 물건 가격 합계를 계산해 오류 여부를 판단하는 것과 유사하다.
- CRC: 데이터의 각 부분을 더 정밀히 확인하며, 각 비트를 특정 규칙에 따라 검증한다. 이는 장바구니의 각 물건 가격을 나누어 오류 여부를 개별적으로 확인하는 방식으로 비유할 수 있다.

---

### 6.2.3 순환 중복 검사(CRC)

순환 중복 검사(Cyclic Redundancy Check, CRC)는 오늘날 컴퓨터 네트워크에서 널리 사용되는 오류 검출 기술이다. CRC는 데이터를 다항식으로 간주하여 연산하며, 이 때문에 다항식 코드(Polynomial Code)라고도 불린다.

#### CRC 동작 과정
1. 송신자와 수신자는 생성자 G로 알려진 r+1 비트 패턴에 대해 합의한다.
   - G의 최상위 비트는 항상 1이어야 한다.
2. 송신자는 원래 데이터 D에 r개의 추가 비트 R을 계산하여 덧붙인다.
   - D 뒤에 r개의 비트를 추가하면 d+r 비트 패턴이 생성된다.
3. 이 d+r 비트 패턴은 모듈로 2 연산을 통해 G로 정확히 나누어진다.
4. 수신자는 d+r 비트를 G로 나누고, 나머지가 0이 아니면 오류가 발생했음을 판단한다.

#### CRC 연산 특징
- CRC 연산은 덧셈의 올림이나 뺄셈의 빌림이 없는 모듈로 2 연산으로 이루어진다.
- 이 연산은 각 비트를 XOR 연산으로 처리한다.

XOR 연산 예시:
- 1011 XOR 0101 = 1110
- 1001 XOR 1101 = 0100

#### 핵심 요약
데이터 뒤에 CRC 값을 붙여 전송.
수신 측에서 같은 계산을 반복해 데이터가 손상되었는지 확인.
CRC는 오류를 검출하는 용도로만 사용되며, 오류를 수정하지는 못한다는 점을 기억하면 된다.

---

### 요약 표

| 기술         | 기능                                 | 특징                                            | 사용 사례                                      |
|-------------------|-----------------------------------------|----------------------------------------------------|--------------------------------------------------|
| 체크섬       | 데이터 전체의 오류 검출                 | 단순히 데이터 합계를 이용, 간단한 오류 검출 가능       | TCP, UDP 등에서 사용                              |
| CRC          | 데이터 각 부분의 정밀한 오류 검출       | 다항식 연산 기반, 높은 오류 검출 정확도              | 네트워크 하드웨어, 링크 계층 등에서 사용           |
| 해밍 코드    | 오류 검출 및 수정                       | 추가 비트를 삽입하여 단일 비트 오류 수정 가능          | 메모리 오류 검출 및 수정                          |
| 패리티 코드  | 간단한 오류 검출                        | 홀수/짝수 합계 확인, 문제 위치나 수정 불가능           | 간단한 데이터 전송 환경, 저비용 시스템            |

---

### 패리티 코드와 체크섬의 차이

1. 패리티 코드:
   - 데이터의 비트 합이 짝수인지 홀수인지를 확인하는 가장 단순한 오류 검출 방식이다.
   - 주로 단일 비트 오류를 감지하는 데 사용되며, 추가적인 정밀 검사는 어렵다.
   - 예: 데이터 비트 `1101`의 합을 계산해 홀수(1) 또는 짝수(0) 패리티로 표현.

2. 체크섬:
   - 데이터의 전체 합계를 계산하여 오류 여부를 확인한다.
   - 패리티 코드보다 한 단계 복잡하며, 여러 비트가 변해도 오류를 검출할 가능성이 높다.
   - 예: 데이터의 모든 값을 더한 결과의 마지막 k 비트를 오류 검출 비트로 사용.

주요 차이: 
- 패리티 코드는 단순히 홀수/짝수 여부만 판단하며 간단한 환경에 적합하지만, 체크섬은 데이터 전체를 기반으로 오류 검출 가능성을 높인다.
- 체크섬은 패리티 코드의 확장된 형태로 볼 수 있다.

---

### 쉬운 비유로 이해하기

- 체크섬:
  마트에서 장바구니에 담긴 물건 가격들을 모두 더한 뒤 마지막 두 자릿수만 기록해둔다고 생각하면 된다. 계산대에서는 이 값을 다시 계산해 기록된 값과 비교하여 물건이 빠졌거나 추가되지 않았는지 확인한다.

- CRC:
  특정 규칙에 따라 장바구니에 담긴 물건 가격들을 나누는 더 복잡한 계산을 한다고 생각하면 된다. 예를 들어, 모든 가격을 특정 숫자로 나누고 나머지를 기록한다. 계산대에서도 같은 방식으로 나누어 나머지를 확인함으로써 장바구니에 문제가 없는지 검증한다.

- 해밍 코드:
  물건 가격마다 오류를 수정할 수 있는 "특별 태그"를 붙인다고 생각하면 된다. 장바구니에 문제가 생기더라도 이 태그를 통해 정확한 가격을 복구할 수 있다.

- 패리티 코드:
  장바구니의 모든 물건 가격을 더한 후, 합계가 짝수인지 홀수인지 확인한다고 생각하면 된다. 간단히 오류 여부만 알 수 있지만, 문제의 위치를 알거나 수정할 수는 없다.


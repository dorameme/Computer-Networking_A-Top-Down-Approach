### **4.3.1 IPv4 데이터그램 포맷**

인터넷 네트워크 계층의 패킷은 데이터그램(datagram)이라고 부르며, 데이터그램의 구조와 각 필드의 역할은 아래와 같다.

---

### **IPv4 데이터그램 포맷 필드 설명**

| **필드명**                | **크기**   | **설명**                                                                                                                                          |
|--------------------------|------------|--------------------------------------------------------------------------------------------------------------------------------------------------|
| **버전 번호**             | 4비트       | - 데이터그램의 **IP 프로토콜 버전**을 명시한다. <br> - 라우터는 버전 번호를 확인하여 데이터그램의 나머지를 어떻게 해석할지 결정한다. <br> - IPv4에서 이 값은 항상 `4`이다. |
| **헤더 길이**             | 4비트       | - **헤더의 실제 길이**를 나타낸다. <br> - IPv4 헤더는 가변 길이를 가지며, 기본적으로 옵션이 없는 경우 **20바이트**이다.                        |
| **서비스 타입**           | 8비트       | - 데이터그램의 **우선순위**를 나타내며, **실시간/비실시간 트래픽**을 구별하는 데 사용된다.                                                      |
| **데이터그램 길이**        | 16비트      | - 데이터그램의 전체 길이(헤더 + 페이로드)를 바이트 단위로 나타낸다. <br> - 최대 값은 `65,535바이트`이지만, 일반적으로 `1,500바이트`를 넘지 않는다. |
| **식별자, 플래그, 단편화 오프셋** | 32비트      | - 데이터그램이 단편화(Fragmentation)될 경우, 이를 조합해 원래의 데이터그램으로 복구한다.                                                   |
| TTL (Time To Live)    | 8비트       | - 데이터그램의 **생존 시간**을 나타낸다. <br> - 데이터그램이 **라우터를 통과할 때마다 1씩 감소**하며, 0이 되면 데이터그램이 폐기된다.             |
| **프로토콜**              | 8비트       | - IP 데이터그램의 페이로드가 어떤 트랜스포트 계층 프로토콜(TCP, UDP 등)에 전달될지 명시한다.                                                 |
| **헤더 체크섬**           | 16비트      | - **IP 헤더의 비트 오류를 탐지**하는 데 사용된다. <br> - TTL이나 옵션 값이 변경될 때마다 각 라우터에서 재계산된다.                              |
| **출발지와 목적지 IP 주소**| 각각 32비트 | - 데이터그램을 생성한 **출발지 IP 주소**와 **목적지 IP 주소**를 저장한다.                                                                         |
| **옵션**                 | 가변 크기    | - IP 헤더를 확장하는 데 사용된다. <br> - 오버헤드 문제로 인해 거의 사용되지 않는다.                                                             |
| 데이터(페이로드)       | 가변 크기    | - 데이터그램의 가장 중요한 필드로, **트랜스포트 계층 세그먼트** 또는 **애플리케이션 계층 메시지**를 포함한다.                                   |

---

### **IPv4 데이터그램의 일반적인 크기**
- 대부분의 IP 데이터그램은 **20바이트의 고정 크기 헤더**를 가진다. (옵션 없음 가정)
- 예: **TCP 세그먼트**를 전송할 경우:
  - 총 헤더 크기: **IP 헤더 20바이트 + TCP 헤더 20바이트 = 40바이트**.
  - 실제 데이터는 이 헤더 이후에 포함된다.

---

### **주요 필드의 역할 요약**
1. **버전 번호**: IPv4 또는 IPv6 등 프로토콜 버전을 식별.
2. **헤더 길이**: 헤더의 시작과 데이터(페이로드)의 위치를 결정.
3. **TTL**: 라우팅 루프 방지, 네트워크에서 데이터그램의 최대 생존 시간 설정.
4. **프로토콜**: 데이터그램의 페이로드가 전달될 트랜스포트 계층 프로토콜(TCP/UDP)을 명시.
5. **헤더 체크섬**: IP 헤더의 비트 오류 탐지.
6. **출발지/목적지 IP 주소**: 데이터그램의 송신자와 수신자를 식별.
7. **페이로드**: 최종 목적지에 도달해야 하는 데이터.

---

### **단편화와 조립**
- **단편화(Fragmentation)**:
  - 데이터그램이 네트워크의 MTU(Maximum Transmission Unit)를 초과하면, **작은 조각**으로 나뉜다.
  - 단편화된 데이터그램은 독립적으로 전달되며, 목적지에서 재조립된다.
- **조립(Reassembly)**:
  - 목적지 호스트는 **식별자, 플래그, 단편화 오프셋**을 사용해 원래 데이터그램으로 복원한다.

---

### **IPv4 데이터그램의 중요성**
- IPv4 데이터그램은 인터넷 네트워크 계층의 핵심으로, **효율적이고 유연한 데이터 전달**을 위해 설계되었다.
- 데이터그램 포맷은 네트워크 라우팅, 오류 검출, 데이터 흐름 제어 등을 가능하게 한다.

## 4.3.2 IPv4 주소체계
![Image](https://github.com/user-attachments/assets/1e1e4318-2bb4-4a05-8425-a1f9cfe02d25)

### CIDR (Classless Inter-Domain Routing)

CIDR(Classless Inter-Domain Routing)은 전통적인 클래스 기반 IP 주소체계(Class A, B, C)를 대체한 방식이다.  
CIDR은 **서브넷 마스크를 명시적으로 사용**하여 유연하고 효율적인 주소 할당을 가능하게 한다.

---

#### **1. CIDR의 구성**
- CIDR은 IP 주소 뒤에 **"/n"** 형태의 숫자를 추가하여 네트워크 부분의 길이를 나타낸다.
  - 예: `192.168.1.0/24`에서 `/24`는 네트워크 주소가 **왼쪽 24비트**임을 의미.
  - 나머지 비트는 **호스트 주소**로 사용.

---

#### **2. CIDR 블록**
CIDR은 네트워크 주소와 서브넷 마스크를 조합하여 주소를 나타낸다.

| **CIDR 블록** | **서브넷 마스크**        | **호스트 개수**   | **예시 네트워크 주소**   |
|---------------|------------------------|-------------------|------------------------|
| `/8`          | 255.0.0.0             | 약 1,600만 개     | 10.0.0.0/8            |
| `/16`         | 255.255.0.0           | 약 65,536개       | 192.168.0.0/16        |
| `/24`         | 255.255.255.0         | 256개             | 192.168.1.0/24        |
| `/30`         | 255.255.255.252       | 4개(사용 가능 2개)| 192.168.1.0/30        |

---

### **클래스 기반 주소체계와 CIDR의 차이**
- **클래스 기반 주소체계**:
  - 고정된 서브넷 마스크를 사용 (A: /8, B: /16, C: /24).
  - 비효율적인 주소 사용(예: 작은 네트워크에 큰 주소 블록 할당).
- **CIDR**:
  - 서브넷 마스크 길이를 유연하게 설정하여 주소를 효율적으로 사용.
  - 주소 낭비를 줄이고 인터넷 라우팅을 단순화.

---

### **브로드캐스트 주소**
브로드캐스트 주소는 **네트워크 내 모든 장치로 패킷을 전송**하기 위한 주소다.

#### **브로드캐스트 주소 계산 방법**
1. 네트워크 주소에서 **호스트 비트 모두를 1로 설정**.
2. 예:
   - 네트워크 주소: `192.168.1.0/24`  
   - 브로드캐스트 주소: **192.168.1.255** (호스트 비트 8개를 1로 설정).

---

### **예제**
#### **CIDR 블록: `192.168.1.0/24`**
1. **네트워크 주소**: `192.168.1.0`
2. **서브넷 마스크**: `255.255.255.0`
3. **호스트 개수**: 256개(2개는 네트워크 주소와 브로드캐스트 주소로 사용).
4. **브로드캐스트 주소**: `192.168.1.255`

#### **CIDR 블록: `192.168.1.0/28`**
1. **네트워크 주소**: `192.168.1.0`
2. **서브넷 마스크**: `255.255.255.240`
3. **호스트 개수**: 16개(14개 사용 가능, 2개는 예약).
4. **브로드캐스트 주소**: `192.168.1.15`
  

#### **서브넷 마스크 계산**
- `/24`는 **24개의 비트가 네트워크를 나타낸다**는 뜻이다.
  - 네트워크 부분: **11111111.11111111.11111111** (24개의 1)
  - 호스트 부분: **00000000** (8개의 0)

- 이 값을 10진수로 변환하면:
  - 네트워크 부분: **255.255.255**
  - 호스트 부분: **0**
  - **서브넷 마스크**: **255.255.255.0**

### **서브넷 마스크가 꼭 1로 채워져야 하는 이유**

1. **네트워크와 호스트 부분의 명확한 구분**
   - 서브넷 마스크는 **1의 연속된 비트**로 네트워크를 나타내고, **0의 연속된 비트**로 호스트를 나타낸다.
   - 만약 네트워크 부분이 **1로 연속되지 않는다면**, 네트워크와 호스트를 구분할 수 없다.
     - 예: `11111111.11111100.11111111.00000000` (네트워크 부분이 연속적이지 않음)  
       → 네트워크가 어디까지인지 명확하지 않음.

2. **비트 연산을 통한 네트워크 주소 계산**
   - IP 주소와 서브넷 마스크는 **AND 연산**으로 네트워크 주소를 계산한다.
     - 예:  
       IP 주소: `192.168.1.10`  
       서브넷 마스크: `255.255.255.0`  
       AND 연산 결과: `192.168.1.0` (네트워크 주소)
   - 서브넷 마스크가 1과 0으로 연속되지 않으면, 정확한 연산이 불가능하다.

3. **표준화된 규칙**
   - 네트워크 통신의 표준화된 규칙에 따라, **서브넷 마스크의 네트워크 부분은 항상 연속된 1로 표현**해야 한다.
   - 이렇게 하면 네트워크 설계와 라우팅을 일관되게 수행할 수 있다.

---

서브넷 마스크의 네트워크 부분이 **항상 연속된 1**로 채워져야 하는 이유는 **네트워크와 호스트를 명확히 구분하고, 표준화된 방식으로 네트워크를 설계**하기 위해서이다.  
비연속적인 서브넷 마스크를 사용하면 네트워크 장비가 이를 해석할 수 없으며, 네트워크의 정상적인 동작을 보장할 수 없게 된다.

---

### **브로드캐스트 주소 특징**
1. 브로드캐스트 주소는 **서브넷의 모든 호스트와 통신**하기 위해 사용된다.
2. 네트워크의 **마지막 주소**를 브로드캐스트 주소로 사용한다.
3. 브로드캐스트는 주로 네트워크 관리와 디스커버리 프로토콜에 활용된다.

---

### **CIDR과 브로드캐스트 주소 요약**
- **CIDR**은 클래스 기반의 비효율성을 해결하기 위해 도입된 방식이다. 네트워크 크기에 따라 적절한 블록을 할당할 수 있다.
- **브로드캐스트 주소**는 서브넷 내 모든 호스트로 패킷을 전송하는 데 사용되며, 서브넷의 마지막 주소로 설정된다.

### **IP 주소 블록 획득과 DHCP 동작**

---

### **IP 주소 블록 획득**
1. **IP 주소 블록 할당**
   - 기관이 서브넷에서 사용할 IP 주소를 얻기 위해, **ISP**(Internet Service Provider)와 접촉해야 한다.
   - ISP는 비영리 단체인 **ICANN**(Internet Corporation for Assigned Names and Numbers)으로부터 주소 블록을 할당받는다.
     - ICANN은 **IP 주소 관리**와 **DNS 루트 서버 관리** 역할을 한다.

2. **주소 블록의 분배**
   - ISP는 할당받은 큰 주소 블록을 더 작은 블록으로 나누어 여러 조직에 분배할 수 있다.
   - 예를 들어, `/16` 블록을 할당받은 ISP는 이를 8개의 `/19` 블록으로 나누어 각기 다른 조직에 제공할 수 있다.

---

### **호스트 주소 획득: DHCP (Dynamic Host Configuration Protocol)**

1. **DHCP 개요**
   - DHCP는 **동적 IP 주소 할당 프로토콜**로, 호스트가 IP 주소 및 기타 네트워크 설정 정보를 자동으로 얻을 수 있게 한다.
   - DHCP는 다음 정보를 제공한다:
     - IP 주소
     - 서브넷 마스크
     - 기본 게이트웨이(첫 번째 홉 라우터 주소)
     - DNS 서버 주소
   - **플러그 앤 플레이 프로토콜** 또는 **제로 구성 프로토콜**이라고도 불린다.

2. **DHCP 동작 방식**
   - DHCP는 **클라이언트-서버 프로토콜**로 작동한다.
   - 클라이언트: 네트워크 설정 정보를 요청하는 새롭게 연결된 호스트.
   - 서버: IP 주소와 네트워크 정보를 제공하는 장치.
   - 각 서브넷은 DHCP 서버를 가지거나, 라우터가 **DHCP 연결 에이전트** 역할을 해야 한다.

---

### **DHCP의 4단계 동작**

#### **1. DHCP 서버 발견**
   - 새롭게 도착한 호스트는 DHCP 서버를 찾기 위해 **DHCP Discover 메시지**를 브로드캐스트로 전송한다.
     - **목적지 IP**: `255.255.255.255` (브로드캐스트 주소)
     - **출발지 IP**: `0.0.0.0` (IP 주소 없음)
   - 이 메시지는 서브넷 내 모든 노드로 전송된다.

#### **2. DHCP 서버 제공**
   - DHCP 서버는 Discover 메시지를 수신하고, **DHCP Offer 메시지**로 응답한다.
     - 클라이언트가 사용할 수 있는 IP 주소, 서브넷 마스크, 임대 기간 등의 정보를 포함한다.
   - 메시지는 브로드캐스트로 전송되며, 클라이언트는 여러 DHCP 서버 중 최적의 서버를 선택한다.

#### **3. DHCP 요청**
   - 클라이언트는 선택된 DHCP 서버에 **DHCP Request 메시지**를 전송한다.
   - 이 메시지를 통해 제공된 IP 주소와 네트워크 설정 정보를 요청한다.

#### **4. DHCP ACK**
   - DHCP 서버는 요청을 확인하고 **DHCP ACK 메시지**로 응답한다.
   - 이 메시지를 받은 클라이언트는 설정된 IP 주소를 사용하기 시작하며, 상호작용이 종료된다.

---

### **DHCP의 한계**
- DHCP는 새로운 서브넷에 연결할 때마다 새로운 IP 주소를 요청해야 한다.
- 노드가 서브넷 사이를 이동하면 기존 **TCP 연결**이 끊어진다는 단점이 있다.

---

### **요약**
- **IP 주소 블록**은 ISP가 ICANN으로부터 할당받고, 이를 작은 블록으로 나누어 조직에 분배한다.
- **DHCP**는 IP 주소를 동적으로 할당하며, 네트워크 설정을 자동화하는 클라이언트-서버 프로토콜이다.
- DHCP는 4단계 과정을 통해 IP 주소를 할당하며, 이동 중 IP 주소가 변경될 경우 TCP 연결 유지가 어려운 단점이 있다.

### 플러그 앤 플레이 프로토콜(Plug and Play Protocol) 또는 제로 구성 프로토콜(Zero Configuration Protocol)

---

### **1. 정의**
- **플러그 앤 플레이 프로토콜** 또는 **제로 구성 프로토콜**은 사용자가 복잡한 네트워크 설정을 수동으로 구성하지 않아도 **자동으로 네트워크 연결을 설정**하는 프로토콜을 의미한다.
- 이 프로토콜은 네트워크 장치(예: 컴퓨터, 프린터, IoT 기기 등)가 네트워크에 연결되었을 때, **자동으로 IP 주소 및 기타 네트워크 설정**을 받아 네트워크 상호작용을 가능하게 한다.

---

### **2. 주요 특징**
- **자동화된 네트워크 구성**:
  - IP 주소, 서브넷 마스크, 게이트웨이, DNS 설정 등을 자동으로 할당한다.
  - 예: DHCP(Dynamic Host Configuration Protocol)는 대표적인 플러그 앤 플레이 프로토콜이다.
  
- **사용자 개입 최소화**:
  - 사용자가 수동으로 네트워크 설정을 입력할 필요 없이, 장치가 자동으로 구성 정보를 받는다.
  
- **유연성**:
  - 네트워크 환경에 쉽게 적응할 수 있어, 이동 중인 장치나 IoT 디바이스에 적합하다.

---

### **3. 예시 프로토콜**
#### 1) DHCP (Dynamic Host Configuration Protocol)
- **동작 방식**:
  - DHCP 서버가 네트워크에 연결된 클라이언트 장치에 **동적으로 IP 주소와 네트워크 정보를 할당**한다.
- **장점**:
  - 설정 간소화: 사용자 개입 없이 자동 설정.
  - IP 주소 효율성: 사용 중인 주소만 할당하고, 사용하지 않는 주소는 반환.

#### 2) Zeroconf (Zero Configuration Networking)
- **동작 방식**:
  - DHCP 서버 없이도 **로컬 네트워크**에서 장치들이 서로를 자동으로 탐지하고 연결할 수 있도록 지원.
  - IP 주소, 서비스 이름 등을 스스로 결정.
- **주요 사례**:
  - **Apple Bonjour**: 프린터, 공유 디스크와 같은 네트워크 장치의 자동 설정과 탐지.
  - **UPnP (Universal Plug and Play)**: 스마트 홈 네트워크에서 기기 자동 연결.

---

### **4. 사용 사례**
1. **일반 사용자 환경**:
   - 가정용 네트워크에서 DHCP로 장치(IP 주소, 게이트웨이 등)를 자동으로 설정.
   - 스마트 기기와 프린터를 연결할 때 Zeroconf를 사용해 자동 탐지.

2. **기업 네트워크**:
   - IT 관리자가 DHCP 서버를 설정해 IP 주소를 중앙에서 관리.
   - 모바일 장치가 기업 네트워크에 연결될 때 자동 설정 제공.

3. **IoT 환경**:
   - IoT 디바이스가 이동하거나 다른 네트워크에 접속할 때, DHCP와 Zeroconf를 통해 자동으로 네트워크 설정 수행.

---

### **5. 장점과 단점**
| **장점**                                        | **단점**                                               |
|-------------------------------------------------|-------------------------------------------------------|
| 사용자 개입이 거의 필요 없으므로 편리함.        | DHCP 서버나 프로토콜에 의존하므로 서버 장애 시 문제가 발생할 수 있음. |
| IP 주소를 효율적으로 사용 가능.                 | IP 충돌 문제 가능성 (예: Zeroconf가 잘못된 설정 생성). |
| 새로운 네트워크 환경에서도 자동 적응.           | 일부 복잡한 네트워크에서는 수동 설정이 필요할 수 있음. |

---

### **플러그 앤 플레이 프로토콜 vs 제로 구성 프로토콜: 차이점**

---

플러그 앤 플레이(Plug and Play Protocol)와 제로 구성(Zero Configuration Protocol, Zeroconf)은 모두 네트워크 설정을 자동화하는 데 목적이 있지만,     
**작동 방식과 환경**에 따라 차이가 있다.

---

### **1. 주요 차이점**

| **특징**                  | **플러그 앤 플레이 프로토콜**                          | **제로 구성 프로토콜**                          |
|---------------------------|----------------------------------------------------|------------------------------------------------|
| **의존성**                | **DHCP 서버**와 같은 외부 장치에 의존                  | DHCP 서버 없이 **자체적으로 네트워크 구성**       |
| **동작 방식**             | 중앙 서버(DHCP)가 IP 주소와 설정 정보를 **동적으로 할당**| 장치가 자체적으로 **IP 주소와 설정을 생성**      |
| **적용 범위**             | **광범위한 네트워크**에서 사용 가능                   | **로컬 네트워크** 또는 소규모 네트워크에서 주로 사용 |
| **사용 사례**             | 기업, ISP, 가정 네트워크 등                          | 스마트 홈, 프린터 연결, IoT 장치 자동 탐지       |
| **IP 주소 충돌 가능성**    | DHCP 서버가 충돌 방지 기능 제공                      | 충돌 방지 기능이 제한적 (IP 충돌 가능성 있음)    |
| **설정 정보**             | IP 주소, 서브넷 마스크, DNS, 게이트웨이 등 **광범위한 정보** | IP 주소와 **기본적인 연결 정보만 제공**          |

---

### **2. 플러그 앤 플레이 프로토콜**
- **중앙 관리 방식**: DHCP 서버와 같은 중앙 관리 장치가 네트워크 설정 정보를 관리하고, 필요한 장치에 **동적으로 할당**한다.
- **적용 환경**:
  - DHCP를 사용하는 일반 가정 네트워크, 기업 네트워크, ISP에서 흔히 사용.
  - 다양한 네트워크 장치(PC, 스마트폰, IoT 장치 등)에 적합.
- **장점**:
  - **대규모 네트워크 관리**에 적합.
  - DHCP 서버를 통해 IP 주소 관리가 체계적으로 이루어짐.
  - IP 충돌 방지 기능 제공.
- **단점**:
  - DHCP 서버가 필요한 환경에서만 동작.
  - 서버 장애 시 네트워크 연결에 문제 발생 가능.

---

### **3. 제로 구성 프로토콜**
- **분산 방식**: DHCP 서버가 없는 환경에서 장치가 자체적으로 **IP 주소를 생성**하고 네트워크를 구성.
- **적용 환경**:
  - 소규모 네트워크(로컬 네트워크) 또는 네트워크 연결이 제한된 환경에서 주로 사용.
  - 예: 스마트 홈 장치, 프린터 자동 연결, Apple Bonjour, UPnP 등.
- **장점**:
  - **서버 없이도 동작**하므로 단순한 네트워크에서 적합.
  - 자동으로 장치 간 네트워크 탐색 및 설정 가능.
- **단점**:
  - IP 충돌 가능성이 있음.
  - DNS, 게이트웨이 등 추가적인 설정 정보 제공이 어렵다.
  - 대규모 네트워크에는 부적합.

---

### **4. 요약**
| **구분**                 | **플러그 앤 플레이**                                  | **제로 구성 프로토콜**                            |
|--------------------------|---------------------------------------------------|-------------------------------------------------|
| **관리 주체**            | DHCP 서버와 같은 중앙 관리 장치가 관리                | 각 장치가 스스로 설정                           |
| **사용 사례**            | 가정, 기업, ISP 네트워크                            | 로컬 네트워크, 스마트 홈, IoT 연결               |
| **환경 요구 사항**       | DHCP 서버 필요                                     | DHCP 서버 없이 동작 가능                        |
| **규모**                 | 대규모 네트워크에 적합                              | 소규모 네트워크에 적합                          |

---

### **5. 결론**
- 플러그 앤 플레이 프로토콜(DHCP 기반)은 DHCP 서버를 이용해 대규모 네트워크에서 네트워크 설정을 관리하는 데 적합하며, 안정성과 확장성이 뛰어나다.
- 제로 구성 프로토콜(Zeroconf)은 서버 없이도 자동 네트워크 설정이 가능하며, 로컬 네트워크나 소규모 환경에서 간편하게 사용된다.

두 프로토콜은 사용 환경과 목적에 따라 선택적으로 사용된다. **DHCP 기반 플러그 앤 플레이는 관리가 필요한 큰 네트워크에서, Zeroconf는 단순한 연결이 필요한 소규모 네트워크에서 적합하다.**

---

### **4.3.3 네트워크 주소 변환 (NAT)**

---

### **1. NAT의 필요성**
- 네트워크가 커지면서 각 호스트가 고유한 글로벌 IP 주소를 받기 위해서는 **큰 주소 블록**이 필요하다.
- 하지만 글로벌 IP 주소의 부족 문제와 ISP가 특정 주소 블록을 이미 사용 중인 경우, **NAT(Network Address Translation)**를 사용하여 이를 해결할 수 있다.

---

### **2. NAT의 동작 원리**

#### **NAT 라우터의 역할**
- NAT 라우터는 홈 네트워크 내부의 **사설 IP 주소**를 외부 네트워크로 보낼 때 **공용 IP 주소로 변환**한다.
- 외부에서 들어오는 트래픽의 **목적지 주소**도 NAT 라우터를 통해 다시 사설 IP 주소로 변환된다.

#### **NAT 변환 과정**
1. 홈 네트워크 내부에서 송신된 데이터그램의 출발지 IP 주소는 **사설 IP 주소(예: 10.0.0.1)**이다.
2. NAT 라우터는 이 데이터를 외부 네트워크로 보낼 때 출발지 IP 주소를 라우터의 공용 IP 주소(예: 138.76.29.7)로 변환한다.
3. 외부 네트워크에서 홈 네트워크로 들어오는 데이터는 라우터의 공용 IP 주소를 목적지 주소로 가진다.
4. NAT 라우터는 **NAT 변환 테이블**을 사용하여 해당 데이터를 올바른 내부 호스트(사설 IP 주소)로 전달한다.

---

### **3. 사설 IP 주소와 권역(realm)**
- NAT는 주로 **사설 IP 주소(private IP)**를 사용하는 네트워크에서 사용된다.
- **사설 IP 주소의 범위**:
  - 10.0.0.0/8
  - 172.16.0.0/12
  - 192.168.0.0/16
- 사설 IP 주소는 네트워크 내부에서만 유효하며, 글로벌 인터넷에서는 사용할 수 없다.

---

### **4. NAT 변환 테이블**
NAT 라우터는 **NAT 변환 테이블**을 통해 내부 호스트와 외부 트래픽 간의 매핑을 유지한다.

#### **NAT 변환 테이블 예시**
| **사설 IP 주소** | **사설 포트** | **공용 IP 주소** | **공용 포트** |
|------------------|---------------|------------------|---------------|
| 10.0.0.1         | 5001          | 138.76.29.7      | 40000         |
| 10.0.0.2         | 5002          | 138.76.29.7      | 40001         |

- 내부 호스트(10.0.0.1, 10.0.0.2)는 공용 IP 주소와 고유한 포트 번호를 통해 외부와 통신한다.
- 외부에서 오는 데이터는 **공용 IP 주소와 포트 번호**를 기반으로 올바른 내부 호스트로 전달된다.

---

### **5. NAT의 장점**
1. **IP 주소 절약**:
   - 하나의 공용 IP 주소로 여러 내부 호스트를 관리할 수 있어 IP 주소 공간을 효율적으로 사용한다.
   
2. **보안 강화**:
   - 외부 네트워크는 홈 네트워크 내부 구조(호스트 수, IP 주소 등)를 알 수 없다.

3. **유연성**:
   - 홈 네트워크가 변경되더라도 공용 IP 주소만 유지하면 외부 네트워크와의 연결에는 영향을 미치지 않는다.

---

### **6. NAT의 한계와 문제**
1. **서버 문제**:
   - NAT는 포트 번호를 사용해 트래픽을 내부 호스트로 전달하기 때문에, 내부 네트워크에서 실행되는 서버가 외부에서 접근하기 어렵다.
   - 예: P2P 프로토콜의 피어는 들어오는 연결을 받아야 하지만 NAT가 이를 방해할 수 있다.

2. **NAT 순회 문제**:
   - NAT 환경에서는 클라이언트 간 직접 연결이 어렵다.
   - 이를 해결하기 위해 **NAT 순회 도구**(예: STUN, TURN, UPnP)가 사용된다.

3. **추가적인 처리 비용**:
   - NAT 라우터는 변환 테이블을 관리하고 데이터그램의 주소를 변환해야 하므로 추가적인 처리 비용이 발생한다.

---

### **7. 요약**
- NAT는 공용 IP 주소의 부족 문제를 해결하기 위해 사설 IP 주소를 사용하는 네트워크에서 **공용 IP 주소로 변환**해주는 역할을 한다.
- NAT 라우터는 공용 IP 주소 하나로 여러 내부 호스트를 관리하며, NAT 변환 테이블을 사용해 트래픽을 올바르게 매핑한다.
- NAT는 보안을 강화하고 IP 주소를 절약하지만, P2P 통신과 같은 직접 연결 환경에서는 제약이 발생할 수 있다. 이를 해결하기 위해 **NAT 순회 기술**이 사용된다.

## **4.3.4 IPv6**

IPv6는 IPv4 주소 공간의 고갈 문제를 해결하고, 네트워크 성능을 향상시키기 위해 설계된 새로운 IP 프로토콜이다. IPv6는 기존 IPv4와 비교해 여러 가지 변화와 이점을 제공한다.

---

### **1. IPv6의 주요 변화**

#### **1) 확장된 주소 기능**
- IPv6는 **128비트 주소**를 사용하여 IP 주소 공간을 크게 확장하였다.
  - IPv4(32비트)에서는 약 43억 개의 IP 주소를 제공하나, IPv6는 사실상 무한한 IP 주소를 제공한다.
- **유니캐스트**, **멀티캐스트**, **애니캐스트** 주소 지원:
  - **유니캐스트**: 단일 호스트로 데이터 전송.
  - **멀티캐스트**: 특정 그룹의 호스트로 데이터 전송.
  - **애니캐스트**: 그룹 내 가장 가까운 호스트로 데이터 전송.

#### **2) 간소화된 헤더**
- IPv6 헤더는 **40바이트 고정 길이**로 설계되어 **라우터가 데이터그램을 더 빠르게 처리**할 수 있다.
- 불필요한 필드 제거 및 새로운 옵션 인코딩으로 유연한 옵션 처리가 가능하다.

#### **3) 흐름 레이블링**
- **흐름 레이블** 필드를 추가하여 특별한 처리가 필요한 데이터그램을 식별 가능.
  - 예: 실시간 서비스 데이터그램이나 특정 품질의 서비스(QoS)를 요구하는 데이터그램.

---

### **2. IPv6 데이터그램 포맷**

#### **IPv6 헤더 필드**
| **필드명**        | **설명**                                                                                     |
|-------------------|---------------------------------------------------------------------------------------------|
| **버전**          | IP 버전을 나타내며, IPv6는 `6`이다.                                                         |
| **트래픽 클래스** | IPv4의 TOS 필드와 유사. 데이터그램의 우선순위를 지정한다.                                       |
| **흐름 레이블**   | 특정 데이터 흐름(예: 실시간 서비스)의 데이터그램을 식별한다.                                   |
| **페이로드 길이** | 헤더 뒤에 오는 데이터의 크기를 바이트 단위로 나타낸다.                                         |
| **다음 헤더**     | 다음 프로토콜(TCP, UDP 등)을 지정한다.                                                        |
| **홉 제한**       | 데이터그램이 라우터를 지날 때마다 1씩 감소하며, 0이 되면 데이터그램은 폐기된다.                  |
| **출발지/목적지 주소** | 데이터그램의 송신자와 수신자의 IP 주소.                                                     |
| **데이터**        | 데이터그램의 페이로드로, 트랜스포트 계층(TCP/UDP)의 데이터가 포함된다.                         |

---

### **3. IPv6에서 제거된 필드**
- IPv6는 IPv4와 비교해 일부 필드를 제거하여 효율성을 높였다:
  1. **단편화/재결합**:
     - IPv6에서는 단편화 작업을 라우터가 아닌 **송신자와 수신자**만 수행한다.
     - 데이터그램 크기가 너무 큰 경우, 라우터는 이를 폐기하고 ICMP 오류 메시지를 송신자에게 보낸다.
  2. **헤더 체크섬**:
     - IPv6는 트랜스포트 계층(TCP/UDP)과 데이터 링크 계층에서 이미 오류 검사를 수행하므로 헤더 체크섬을 제거하였다.
  3. **옵션 필드**:
     - IPv6 헤더는 고정 길이를 유지하며, 필요한 옵션은 **다음 헤더**로 처리한다.

---

### **4. IPv4에서 IPv6로의 전환**

IPv4에서 IPv6로 완전 전환은 어려운 과제다. 두 프로토콜은 상호 호환되지 않으므로, 이를 해결하기 위한 방법들이 필요하다.

#### **1) 플래그 데이 선언**
- 모든 인터넷 장비를 IPv6로 전환하는 시간을 정해 일괄적으로 업그레이드하는 방식.
- 과거에는 가능했으나, 현재 수억 대의 장치가 인터넷에 연결된 상황에서는 불가능하다.

#### **2) 터널링**
![Image](https://github.com/user-attachments/assets/8cb70e10-bf0d-4c9b-86a9-9877a0ce1414)
- IPv6 데이터그램을 IPv4 데이터그램에 포함하여 IPv4 네트워크를 통해 전송하는 방식.
- **터널링 동작 과정**:
  1. 송신 IPv6 노드가 IPv6 데이터그램을 IPv4 데이터그램의 **데이터 필드**에 캡슐화.
  2. IPv4 데이터그램의 목적지 주소를 터널의 수신 IPv6 노드로 설정.
  3. 터널 내 IPv4 라우터는 캡슐화된 IPv6 데이터그램을 처리하지 않고 일반 IPv4 데이터그램처럼 전달.
  4. 수신 IPv6 노드가 IPv4 데이터그램에서 IPv6 데이터그램을 추출해 목적지로 전달.

---

### **5. IPv6의 장점**
1. **확장된 주소 공간**:
   - 128비트 주소를 통해 사실상 무한한 IP 주소를 제공.
2. **간소화된 헤더**:
   - 40바이트 고정 길이 헤더로 라우터의 처리 속도 증가.
3. **보안 및 품질 강화**:
   - IPsec과 같은 보안 기능 기본 지원.
   - 흐름 레이블을 통해 QoS 제공 가능.
4. **효율적인 데이터 전송**:
   - 라우터에서 단편화 작업을 제거하여 데이터 처리 속도 향상.

---

### **6. IPv6의 단점**
1. **전환의 어려움**:
   - 기존 IPv4 장비와 호환되지 않아 완전 전환이 어려움.
2. **네트워크 복잡성**:
   - 터널링과 같은 방법은 추가적인 오버헤드를 발생시킬 수 있음.

---

### **7. 요약**
IPv6는 주소 공간 부족 문제를 해결하고 네트워크 성능을 개선하기 위해 설계된 차세대 IP 프로토콜이다.  
- 128비트 주소로 확장된 공간 제공.
- 간소화된 고정 길이 헤더와 흐름 레이블 등 효율성을 강화.  
IPv4와의 호환성 문제를 해결하기 위해 터널링과 같은 기술이 사용되며, IPv6로의 전환은 현재 진행 중이다.

# 웹과 HTTP
- 인터넷: 도로망이나 철도망처럼 정보를 전달하는 물리적 인프라.
- 웹: 그 도로 위를 달리는 자동차나 기차처럼 정보를 실어 나르는 특정 서비스.(HTTP/ HTTPS 프로토콜 이용 & 온-디멘드 형식)


## 2.2.1 HTTP 개요
- HTTP는 웹의 중심이다.
- 웹은 서버와 클라이언트라는 두가지 프로그램으로 구현되며,  
서로 다른 종단 시스템에서 수행되는 클라이언트와 서버 프로그램은 이를 통해 메세지를 교환한다.

- 웹 페이지라는 객체로 구성도며 단일 URL을 통해 단일 객체에 접근 가능하다.
- 웹 페이지는 다양한 참조객체와 기본 HTML파일로 구성된다.
  ex) HTML 파일과 이미지 3개 -> 4개의 객체
  
- 각 URL은 호스트네임과 객체의 경로이름 두개의 요소를 가진다.
-        ex) https://[leetcode.com](호스트네임)/[problems/divide-two-integers](경로이름)
        leetcode.com(호스트네임)
        problems/divide-two-integers(경로이름)
- 웹 브라우저는(웹 클라이언트) 요구한 웹페이지를 보여주고 인터넷의 여러 특성을 제공한다.
- 웹 브라우저 예) 크롬
- 웹 서버는 URL로 지정한 각각의 웹 객체를 가지고 있다.
  웹 서버 예) 아파치, 마이크로소프트 인터넷 인포메이션 서버
- HTTP는 TCP를 사용한다.
-     1. HTTP 가 서버에 TCP 연결을 한다.
      2. 연결 뒤 브라우저와 서버는 소켓인터페이스로 TCP에 접속한다.
      3. 소켓인터페이스는 입구이자 출입구이다. (문)
      4. 메세지가 소켓인터페이스로 보내지면 TCP가 전송을 책임진다. 웹 클라이언트는 이 이후는 책임지지 않는다.
         이는 계층구조의 장점 중 하나로 HTTP(애플리케이션 게층)은 TCP가 어떻게 데이터를 복구하고 순서를 배열하는지 알필요 없다.
- 서버는 클라이언트에 대한 상태정보를 저장하지 않는다.    
  이러한 특징은 HTTP가 '비상태 프로토콜'이라고 이라고한다.
- 웹 서버는 고정IP주소를 가지며 언제나 켜져있고 웹 클브라우저의 요청을 서비스한다.

## 2.2.2 비지속 연결과 지속 연결
### 비지속 연결 : 요청할때마다 연결을 새로함
  따라서 TCP버퍼 할당, TCP변수가 계속 유지되어야한다. 이는 웹서버에 부담을 줄 수 있다.
- 비지속 연결은 하나의 요청마다 [2RTT + HTML 파일을 서버가 전송하는데 걸리는 시간] 이 걸린다.
- 따라서 단점으로 매번 새로운 연결이 생성되고 유지되어야 한다는 것 & TCP변수들이 클라이언트와 서버 양측에 유지되어야 한다는것,
  각 객체는 2RTT를 필요로 한다는 것이다. (연결에 1RTT, 객체의 파일 요청하고 받는데 1RTT) + @(전체 파일 수신)
### HTTP1.1 지속연결 (비지속도 지원)
- 객체에 대한 요구는 응답을 기다리지않고 지속연결과 파이프라이닝을 통해 연속해서 만들어 질수 있다.
- HTTP서버는 타임아웃이 되면 연결을 닫는다.

### HTTP 메세지 포맷
### 요청메세지
### 1. 구성
-      ASCII코드라서 사람이 읽을 수 있다.
        첫줄은 요청라인 그 다음부터는 헤더라인 이라 부름
        요청라인은 method필드 , URL필드, HTTP version 필드로 이루어진다.
        GET방식은 브라우저가 URL필드로 식별되는 개체를 요청할 때 사용된다.
        POST방식은 개체 몸체(body)를 가지고 GET은 비어있다.
        메세지는 총 다섯줄로 이루어져 있다. 각줄은 CR & LF로 끝나서 구분이 가능하다. 더 길어질 수도 있음.
         
### 응답메세지
### 1. 구성
-        응답메세지는 상태라인, 6개의 헤더라인 , 개체 몸체로 이루어 진다.
        상태라인은 3개의 필드인 버전필드, 상태코드, 해당 상태메세지로 이루어진다. (HTTP/1.1 200 OK)
         date는 수정된 시간이아닌 요청에 대한 응담메세지를 보낸시간이라는 것에 유의하자.
      Last-modified가 객체가 생성되거나 마지막으로 수정된 시간이다.

### 2. 상태코드와 상태메세지
-     200 OK
       301 Moved Permanently
      400 Bad Request
      404 Not found
      505 HTTP version not Supported

## 2.2.4 사용자와 서버 간의 상호작용

### 쿠키
- HTTP가 비상태 프로토콜이기에 쿠키는 사이트가 사용자를 추적하도록 돕는 역할을 함.
- 처음 요청이 들어오면 서버에서는 식별자인 쿠키를 만들어 클라이언트에 전달하고, 백엔드 데이터베이스에 엔트리를 만들어 쿠키에 대한 정보를 저장함
- 두번째 요청이 들어오면 클라이언트가 요청과 함께 쿠키를 보내고 , 서버는 데이터베이스에서 해당하는 쿠키를 꺼내 서비스를 제공함.
- 이후 쿠키라는 식별자를 이용해 그녀의 데이터베이스 상 정보를 (이름 전자메일 신용카드번호 등) 연걸한다.
-     쿠팡에서의 사용 예시    
      1. 자동 로그인:
      사용자가 '로그인 유지' 옵션을 선택하면, 쿠키에 사용자 인증 정보(암호화된 토큰)를 저장하여 자동 로그인이 가능하게 함.
      2. 빠른 결제:
      결제 정보를 저장하고 보안 토큰을 쿠키나 세션에 유지하여 재입력 없이 결제 진행.
      3. 장바구니 유지:
      장바구니 항목이 페이지를 닫아도 사라지지 않는 이유는 쿠키에 해당 정보가 저장되었기 때문임.
- 위와 같은 예시는 사용자 경험을 편리하게 하지만, 사생활 침해로 보일 수 있어 이슈거리다.

---
## 2.2.5 웹 캐싱

### 웹캐시/ 프록시서버
- 웹서버의 부하를 줄이기 위해 고안되었다.
- 자체의 저장디스크를 가지고 있어 최근에 호출된 객체애 대해 사본을 저장하고 보존하는 역할을 함.
- 캐시는 웹브라우저의 서버이자 웹서버의 클라이언트이다.
- 응답시간을 줄이고, 인터넷 전체의 웹트래픽(네트워크 혼잡)을 줄일 수 있다.   
 이를 통해 모든 애플리케이션의 성능을 개선함.
- 인터넷 성능 개선을 위해 회선을 증설하는 것보다 웹캐시를 구매하여 사용하는것이 저렴하다.
- 웹캐시의 일종인 콘텐츠 전송 네트워크 (CDN)를 통해 캐시는 인터넷에서 중요한 역할을 수행하고 있다.

## 조건부 GET 
- 현재 프록시서버의 웹 캐시가 최신인지 확인하는 경우 사용된다.
- 응답메세지의 Last-Modified 가 이를 위해 사용된다.
-      브라우저가 웹캐시에 요청 -> 브라우저를 대신해 웹캐시가 요청을 서버에 대신 전달
        웹서버는 Last-Modified가 다르면 웹 캐시에 갱신된 데이터를 포함해서 응답메세지를 보내고,
        그게아니면 웹 캐시에게 응답메세지만 보낸다.
- 이러한 조건부 GET은 비단, 대역폭 낭비를 막는것은 물론이고 사용자의 응답시간을 줄여준다.
 ---아래는 **이다/한다**체로 수정한 내용입니다:

---

## HOL (Head of Line) Blocking 문제

### 개요
HTTP/1.1에서는 **지속적인 연결**(Keep-Alive)을 사용하여, 웹 페이지당 하나의 TCP 연결을 유지하면서 서버에서의 소켓 수를 줄이고, 각 웹 페이지가 공정한 네트워크 대역폭을 가질 수 있게 한다. 

그러나 하나의 TCP 연결에서 여러 웹 페이지를 전송하면 **HOL Blocking** 문제로 성능 저하가 발생할 수 있다. HOL Blocking은 하나의 경로에서 패킷이 블로킹되면 그 뒤에 있는 다른 패킷들도 전송되지 못하는 문제이다.

### HOL Blocking 문제 발생 상황
**HOL Blocking**은 주로 **패킷 스위칭 네트워크**에서 발생하며, 패킷들이 네트워크를 통해 전송될 때 하나의 패킷이 특정 경로에서 블로킹되면 그 뒤에 있는 패킷들도 그 경로를 사용할 수 없게 되어 전체 성능이 저하된다.

#### 예시:
- 패킷 스위칭 네트워크에서 여러 패킷들이 하나의 큐에 저장될 때, 큐의 앞에 있는 패킷이 처리되지 않으면 그 뒤에 있는 다른 패킷들도 전송되지 못하는 상황이 발생한다. 이 현상을 **HOL Blocking**이라고 한다.

### HOL Blocking의 원인
1. **큐에 있는 패킷이 처리되지 않음**: 큐에서 패킷들이 대기하고 있을 때, 앞에 있는 패킷이 전송되지 않으면 그 뒤에 있는 패킷들도 전송되지 못하는 상황이 발생한다.
2. **패킷 경로에서의 충돌**: 네트워크에서 여러 경로를 통해 패킷을 전송하려 할 때, 한 경로에서 패킷 처리에 장애가 발생하면, 다른 패킷들도 그 경로를 사용해야 하므로 대기하게 된다.

### 해결 방법
**HOL Blocking**을 해결하기 위한 방법은 다음과 같다:

1. **다중 큐 사용**: 하나의 큐에 모든 패킷을 넣는 대신 여러 개의 큐를 사용하여 패킷을 분산시킬 수 있다.      
   큐의 헤드에서 블로킹이 발생하더라도 다른 큐에서 패킷을 처리할 수 있게 된다.
   
3. **우선순위 큐 사용**: 패킷에 우선순위를 부여하고, 높은 우선순위를 가진 패킷을 먼저 처리하도록 한다.      
   중요한 패킷들이 먼저 처리되어 대기 시간을 줄일 수 있다.

5. **패킷 분산 처리**: 패킷을 여러 경로로 분산시켜서, 하나의 경로에서 블로킹이 발생하더라도 다른 경로를 통해 패킷이 전송되도록 한다.
   특정 경로에서의 블로킹을 방지할 수 있다.

---

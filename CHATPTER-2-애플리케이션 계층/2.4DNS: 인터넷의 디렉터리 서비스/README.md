# 인터넷의 디렉터리 서비스
- 호스트네임과 IP로 호스트를 식별가능하다.
- IP주소는 4바이트 계층구조를 가진다.    
  0~255의 십진수로 표현이 되고 각 바이트는 점(.)으로 구분되어 왼쪽부터-오른쪽으로 조사하며 인터넷의 어디로 위치하는지 알 수 있다.

## 2.4.1 DNS가 제공하는 서비스
라우터입장에서 호스트네임 보다는 고정길이의 계층구조를 가진 IP주소를 선호한다.
그렇기에 호스트네임을 IP주소로 변환하는 디렉터리 서비스가 필요하다.

## DNS 개요
### 1. DNS란?
- DNS(Domain Name System)는 **애플리케이션 계층의 프로토콜**이다.
- 질의와 응답메세지는 포트 번호 **53번**의 UDP데이터그램으로 보내진다.
- DNS는 계층 구조로 구현된 **분산 데이터베이스**이며, 인터넷에서 **호스트네임을 IP 주소로 변환**하는 기능을 제공한다.
- HTTP, SMTP, FTP 등 다양한 애플리케이션 프로토콜이 DNS를 사용하여 호스트네임을 목적지 IP 주소로 변환한다.

### 2. DNS의 특징
- **캐시 사용:** 평균 DNS 지연을 줄이고 네트워크 트래픽을 감소시킨다.
- **확장성:** 계층적 구조를 통해 높은 확장성을 제공한다.
- **분산 데이터베이스:** 여러 DNS 서버가 협력하여 대규모 데이터 관리가 가능하다.

## 3. DNS의 부가 서비스
### 3.1 호스트 엘리어싱
- 복잡한 정식 호스트네임 대신 별명(alias)을 제공한다.
- 예: `www.example.com` 대신 `example.com`으로 쉽게 접근 가능.

### 3.2 메일 서버 엘리어싱
- 메일 서버의 정식 이름 대신 별칭을 제공하여 메일 서버 관리 및 접근을 단순화한다.

### 3.3 부하 분산 (Load Balancing)
- **대규모 사이트**는 여러 서버가 동일한 콘텐츠를 제공하고 각 서버는 서로 다른 IP 주소를 가진다.
- DNS 서버는 여러 IP 주소를 순환 방식으로 응답하여 **트래픽을 분산**시킨다.

### 부하 분산 작동 원리:
1. 사용자가 웹사이트에 접속하면, 브라우저는 DNS 서버에 **IP 주소 요청**을 보낸다.
2. DNS 서버는 해당 사이트의 **여러 IP 주소 목록**을 가지고있다.
3. 클라이언트는 순환 방식으로 응답을 받아 첫 번째 요청에는 IP 주소 A, 두 번째 요청에는 IP 주소 B를 받는다.
4. 결과적으로 요청이 여러 서버로 분산되어 **과부하를 방지**하고, 안정적인 서비스를 제공한다.

### 4. 정리
- DNS는 단순히 **호스트네임을 IP 주소로 변환**하는 기능 외에도 **부하 분산**, **호스트 및 메일 엘리어싱** 등의 다양한 기능을 제공한다. 이를 통해 **빠르고 안정적인 네트워크 서비스**를 지원하며, 인터넷 서비스의 핵심 인프라로 작동한다.
---
## DNS: 클라이언트와 서버 패러다임을 통한 주요 네트워크 기능
1. 클라이언트-서버 구조로 통신하는 종단사이에서 수행됨.
2. DNS 메세지를 전달하기 위해 하위 종단 트랜스포트 프로토콜인 UDP에 의존하는 애플리케이션 계층 프로토콜이다.
3. 다른 애플리케이션과는 다르게 사용자와 직접 상호소통하는 애플리케이션이 아니다.

## 2.4.2 DNS 동작 원리 개요
###  만일 인터넷 네임서버가 1개 였다면?
1. 서버고장: 1개 고장으로 모든 전체 인터넷 마비
2. 트래픽 양: 단일 서버에 수많은 호스트에서 발생된 (HTTP 요청과 전자메이 메세지 처리로 인한) DNS질의를 처리해야함.
3. 먼거리의 중앙 집중 데이터베이스: 단일 DNS와 멀리떨어진 곳에서의 요청은 지연을 일으킴.
4. 유지관리: 단일 서버에 모든 인터넷 호스트에 대한 레코드를 운영해 거대해지며, 새로운 호스트를 등록하기위해 자주 갱신이 필요.

따라서 요약하자면 확장성이 전혀없기에 DNS는 분산되도록 설계되었다.

---
### 분산 계층 데이터베이스

1. **ROOT DNS 서버**

   - 인터넷에는 400개 이상의 루트 DNS 서버가 존재한다. 이 루트 서버들은 13개의 다른 기관에서 관리된다.
   - 이 서버는 DNS 시스템의 최상위에 위치하며, TLD 서버의 위치를 알고 있다. 사용자가 도메인 이름을 입력하면, 먼저 ROOT DNS 서버에 요청이 전달된다.
   - ROOT DNS 서버는 요청된 도메인의 TLD에 대한 정보(예: .com, .org 등)를 포함하는 TLD 서버의 주소를 응답으로 반환한다.

2. **TLD (Top-Level Domain) 서버**

   - TLD 서버는 특정 최상위 도메인에 대한 정보를 관리한다. 예를 들어, `.com`, `.org`, `.net` 등이 있다.
   - `kr`, `jp`, `uk` 등 모든 국가의 상위 레벨 도메인에 대한 도메인에 대한 TLD 서버가 있다.
   - ROOT DNS 서버로부터 TLD 서버 주소를 전달받은 후, TLD 서버는 해당 도메인에 대한 중간 DNS 서버의 주소를 제공한다.
   - TLD 서버는 호스트네임에 대한 최종 책임 DNS 서버를 직접 알지 못한다. 대신, 책임 DNS 서버에 대한 정보를 알고 있는 중간 DNS 서버의 위치를 반환한다.

3. **책임 DNS 서버**

   - 최종적으로, 책임 DNS 서버는 특정 도메인 이름에 대한 최종적인 IP 주소 정보를 가지고 있다. 예를 들어, `example.com`에 대한 IP 주소는 해당 도메인에 대한 책임이 있는 DNS 서버에서 제공한다.
   - TLD 서버로부터 전달받은 정보에 따라, 책임 DNS 서버는 사용자가 요청한 도메인 이름에 대한 IP 주소를 응답으로 반환한다.
   - 인터넷에서 접근하기 쉬운 호스트를 가진 모든 책임 기관은 호스트 네임을 IP 주소로 매핑하는 공개적인 DNS 레코드를 제공해야 한다.\
     (대부분의 대학과 큰 기업은 자신의 기본 책임 DNS 서버와 보조 책임 DNS 서버를 유지하고 구현한다.)

4. **로컬 DNS 서버**

   - 로컬 DNS 서버는 사용자의 컴퓨터 또는 네트워크와 가장 가까운 DNS 서버로, ISP(인터넷 서비스 제공자)나 조직에서 제공한다.
   - 로컬 DNS 서버는 자주 요청되는 도메인 이름을 캐시(Cache)에 저장하여, 동일한 요청이 반복될 때 빠르게 응답할 수 있다.
   - 도메인 정보가 캐시에 없는 경우, 루트 DNS 서버부터 순차적으로 쿼리를 수행하며 최종 IP 주소를 얻어낸다.
   - 캐시 기능 덕분에 트래픽 부하가 감소하며 DNS 조회 속도가 크게 향상된다.
   - 또한, 네트워크 보안 정책을 적용하거나 특정 도메인 접근을 제한하는 기능을 수행할 수 있다.

### DNS 상호작용 흐름

1. 사용자가 `www.example.com`을 방문하려고 한다.
2. 로컬 DNS 서버가 먼저 캐시를 확인하고, 캐시에 정보가 없으면 ROOT DNS 서버에 요청을 전달한다.
3. ROOT DNS 서버는 `.com` 도메인에 대한 TLD 서버의 정보를 반환한다.
4. TLD 서버는 책임 DNS 서버를 직접 반환하지 않고, 해당 정보를 알고 있는 중간 DNS 서버의 위치를 반환한다.
5. 중간 DNS 서버는 책임 DNS 서버의 주소를 제공한다.
6. 책임 DNS 서버는 `example.com`의 최종 IP 주소를 반환한다.
7. 로컬 DNS 서버는 이 정보를 캐시에 저장하고 사용자에게 반환하여 웹사이트에 연결한다.

이러한 계층 구조와 상호작용 방식은 DNS 쿼리가 정확하게 처리되고, 빠르고 효율적인 도메인 이름 해석을 가능하게 한다.

### 재귀적 질의와 반복적 질의 비교

| 구분        | 재귀적 질의 (Recursive Query)             | 반복적 질의 (Iterative Query)         |
| --------- | ------------------------------------ | -------------------------------- |
| **요청 방식** | 클라이언트가 최종 IP 주소를 얻을 때까지 서버가 대신 질의 수행 | 클라이언트가 여러 서버에 직접 질의를 반복 수행       |
| **처리 주체** | 로컬 DNS 서버가 질의를 처리하고 최종 결과만 클라이언트에 반환 | 클라이언트 또는 로컬 DNS 서버가 직접 질의 과정을 관리 |
| **특징**         | 클라이언트는 중간 과정에 관여하지 않음                           | 클라이언트가 질의 과정을 직접 제어                              |
| **장점**         | 간편한 처리, 최종 결과만 반환                                     | 유연한 질의 수행, 특정 단계 건너뛰기 가능                         |
| **단점**         | 서버에 높은 부하 발생 가능                                       | 클라이언트가 직접 관리해야 하므로 복잡성 증가                     |

두 방식의 차이는 재귀적 질의는 클라이언트가 서버에 모든 처리를 위임하고,   
반면, 반복적 질의는 클라이언트가 직접 여러 서버에 질의를 수행하여 정보를 얻는다는 점이다.
---
### DNS 캐싱
-  캐싱을 통해 불필요한 추가 네트워크 질의를 줄이고 빠른 응답을 제공한다.
- 클라이언트(사용자 장치) 캐싱   
웹 브라우저나 운영체제 수준에서 DNS 정보를 캐싱한다.    
이를 통해 동일한 도메인에 대한 재요청 시, 네트워크를 거치지 않고 빠르게 응답한다.   
- 로컬 DNS 서버 캐싱
ISP 또는 조직의 DNS 서버가 주로 사용자의 요청을 처리하고 캐시한다.   
일정 시간 동안 이전에 조회된 정보를 저장해 반복 질의 시 응답 속도를 향상시킨다.   
- 상위 DNS 서버(예: TLD 서버) 캐싱
상위 DNS 서버도 자주 참조되는 도메인 정보를 캐싱한다.   
이를 통해 요청이 반복될 경우, 하위 단계까지 질의를 수행하지 않고 응답할 수 있다.   
- 책임이 없다 하더라도 IP 주소를 제공한다.
- 영구적이지 않고 보통 흔히 2일로 저장 기간을 설정한다.
- 예를 들어, `www.example.com`에 대한 정보를 요청했을 때 로컬 DNS 서버가 이전에 이 정보를 요청한 적이 있다면 캐시된 IP 주소를 반환한다.

## 2.4.3 DNS 레코드와 메시지

### 자원 레코드 (Resource Record)
- DNS 레코드는 DNS 서버에 저장되어 있다. DNS 서버는 도메인 이름과 관련된 정보를 관리하고, 요청이 들어오면 그에 맞는 정보를 제공    
- 자원 레코드는 호스트네임과 IP 주소를 매핑하는데 사용된다.
- 자원 레코드는 4개의 투플로 이루어져 있다:
  Name, Value는 Type에 따라 결정된다.
  1. **Name**: 레코드가 지정하는 도메인 이름.
  2. **Value**: 레코드와 관련된 값.
  3. **Type**: 레코드의 종류를 나타내는 값(예: A, NS, CNAME, MX 등).
  4. **TTL (Time to Live)**: 자원 레코드의 생존 기간 (초 단위).

### 각 Type에 따른 의미
- **Type=A**: 호스트 이름을 IP 주소에 매핑 (Value는 IP 주소).
- **Type=NS**: 도메인 네임 시스템에서 네임서버의 이름을 지정 (Value는 네임서버의 호스트 이름).
- **Type=CNAME**: 별칭을 사용해 도메인 이름을 다른 도메인 이름에 매핑 (Value는 대상 도메인 이름).
- **Type=MX**: 이메일을 위한 메일 서버를 지정 (Value는 메일 서버의 호스트 이름).

### 1. **A 레코드 (Type=A)**
- **목적**: 도메인 이름을 **IP 주소**에 연결
- **예시**: 
  - `example.com` → `192.168.1.1`
  - **예시 코드**: 
    ```
    example.com. IN A 192.168.1.1
    ```

### 2. **NS 레코드 (Type=NS)**
- **목적**: 도메인을 관리하는 **네임서버**를 지정
- **예시**: 
  - `example.com` → `ns1.exampledns.com` (네임서버)
  - **예시 코드**: 
    ```
    example.com. IN NS ns1.exampledns.com.
    ```

### 3. **CNAME 레코드 (Type=CNAME)**
- **목적**: 한 도메인 이름을 **다른 도메인 이름**에 연결 (별칭)
- **예시**: 
  - `www.example.com` → `example.com` (별칭)
  - **예시 코드**: 
    ```
    www.example.com. IN CNAME example.com.
    ```

### 4. **MX 레코드 (Type=MX)**
- **목적**: 도메인의 이메일을 처리할 **메일 서버**를 지정
- **예시**: 
  - `example.com` → `mail.examplemail.com` (메일 서버)
  - **예시 코드**: 
    ```
    example.com. IN MX 10 mail.examplemail.com.
    ```

### 5. **MX 레코드 + CNAME (메일 서버 별칭 사용)**
- **목적**: 이메일 서버를 별칭으로 지정 (CNAME 사용)
- **예시**: 
  - `example.com` → `mail.example.com` (메일 서버 별칭)
  - `mail.example.com` → 실제 메일 서버 `mailhost.example.com`
  - **예시 코드**: 
    ```
    example.com. IN MX 10 mail.example.com.
    mail.example.com. IN CNAME mailhost.example.com.
    ```
---

## DNS 취약점


### DDoS 대역폭 플러딩
- **목적**: 대량의 패킷을 **DNS 서버**에 보내 대역폭을 초과하게 만드는 공격이다.
- **기법**: 공격자는 DNS 서버를 마비시키기 위해 많은 양의 요청을 보내서, 서버가 정상적인 요청을 처리하지 못하게 만든다.
- **실제 사례**: 공격자가 **DNS 루트 서버**로 다량의 패킷을 보내려고 시도했으나, 대부분의 **루트 서버**는 ICMP 핑 메시지를 차단하는 **패킷 필터**로 보호되어 피해가 미미했다. 또한, **로컬 DNS 서버**들이 최상위 도메인 서버(TLD 서버)의 IP 주소를 **캐싱**하고 있어 큰 피해를 입지 않았다.
- **효과적인 공격 방향**: TLD를 노리자!     
  최상위 도메인 서버(TLD 서버)가 루트 서버보다 더 효과적인 공격 대상인 이유는,     
 TLD 서버가 더 많은 도메인 정보를 관리하고 있어, 공격이 성공할 경우 더 많은 도메인에 영향을 미쳐 DNS 시스템 전체에 광범위한 장애를 일으킬 수 있기 때문이다

### 중간자 공격 (Man-in-the-Middle Attack)
- **목적**: 공격자가 **DNS 요청**과 **응답** 사이에 개입하여 데이터를 탈취하거나 수정하는 공격이다.
- **기법**: 공격자는 사용자와 DNS 서버 간의 통신을 가로채서, DNS 응답을 변조하거나 잘못된 정보를 제공한다. 이를 통해 사용자가 악의적인 사이트로 연결되도록 유도하거나 개인정보를 탈취할 수 있다.
- **위험성**: 사용자는 정상적인 웹사이트에 접속한 것처럼 보이지만, 실제로는 공격자가 제어하는 사이트에 접속하게 된다. 이로 인해 **피싱**이나 **악성 코드 배포**가 이루어질 수 있다.

이 두 가지 취약점은 DNS 시스템의 보안에 큰 영향을 미칠 수 있으며, DNS 서비스의 안정성과 신뢰성을 위협한다.- **현재 상황**: 지금까지 DNS 서비스에 대한 공격은 많았지만, **성공적으로 DNS 서비스 자체를 방해**하는 공격은 없었다.

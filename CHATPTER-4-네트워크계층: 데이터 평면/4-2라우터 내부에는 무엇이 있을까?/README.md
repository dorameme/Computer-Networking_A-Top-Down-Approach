## **라우터 내부 구조**

라우터는 입력 포트, 스위치 구조, 출력 포트, 라우팅 프로세서로 구성되어 있으며, 각각의 역할과 기능은 다음과 같다.

![Image](https://github.com/user-attachments/assets/07b13aba-56c1-4088-ad0c-d744f8d1d25a)
---

#### **1. 입력 포트**
- **기능**:
  1. **물리 계층 기능 수행**: 입력 링크에서 데이터를 수신하고 디지털 신호로 변환한다.
  2. **링크 계층 기능 수행**: 들어오는 링크의 반대편에 있는 링크 계층과 상호 운용한다.
  3. **검색 기능 수행**: 
     - 포워딩 테이블을 참조하여 도착한 패킷의 목적지 출력 포트를 결정한다.
     - 스위치 구조를 통해 패킷을 출력 포트로 전달한다.
  4. **제어 패킷 처리**: 라우팅 프로토콜 관련 제어 패킷은 라우팅 프로세서로 전달한다.

- **특이 사항**: 여기서 "포트"는 링크 연결 단위로, 일반적인 출력 포트와 구별된다.
입력 포트는 들어오는 곳이고, 출력 포트는 나가는 곳이다.           
하지만 입력 포트는 포워딩 결정, 출력 포트는 패킷 전송 준비라는 추가적인 역할을 수행한다는 점이 차이이다.    
입력 포트: "패킷 들어와서 어디로 보낼지 정하는 곳."    
출력 포트: "패킷 나가기 전에 마지막 준비하는 곳."     
---

#### **2. 스위치 구조**
- **역할**: 라우터의 입력 포트와 출력 포트를 연결한다.
- **위치**: 라우터 내부에 포함되며, 입력 포트에서 온 패킷을 출력 포트로 전달한다.

---

#### **3. 출력 포트**
- **기능**:
  1. 스위치 구조에서 수신한 패킷을 저장한다.
  2. 필요한 **링크 계층** 및 **물리 계층 기능**을 수행한다.
  3. 패킷을 출력 링크로 전송한다.
- **특이 사항**: 링크가 양방향일 경우 출력 포트는 일반적으로 동일한 링크의 입력 포트와 한 쌍을 이룬다.

---

#### **4. 라우팅 프로세서**
- **역할**: 제어 평면 기능을 수행한다.
- **기능**:
  1. **전통적인 라우터**:
     - 라우팅 프로토콜을 실행한다.
     - 라우팅 테이블과 연결된 링크 상태 정보를 유지 관리한다.
     - 포워딩 테이블을 계산한다.
  2. **SDN 라우터**:
     - 원격 컨트롤러와 통신하여 계산된 포워딩 테이블 엔트리를 수신한다.
     - 수신된 엔트리를 입력 포트에 설치한다.
  3. **네트워크 관리**: 라우터의 상태를 관리하고 제어한다.

---

#### **구현 방식**
- **하드웨어 기반**: 입력 포트, 출력 포트, 스위치 구조는 대부분 하드웨어로 구현된다.
- **소프트웨어 기반**: 제어 평면은 라우팅 프로세서(일반적으로 CPU)에서 소프트웨어로 구현된다.

---

#### **요약**
라우터는 입력 포트에서 패킷을 수신하고, 스위치 구조를 통해 출력 포트로 전달한 후, 최종적으로 출력 링크를 통해 패킷을 전송한다. 
라우팅 프로세서는 라우팅 및 네트워크 관리를 담당하며, SDN 환경에서는 원격 컨트롤러와 협력하여 포워딩 테이블을 유지한다.


## **4.2.1 입력 포트 처리 및 목적지 기반 전송**

---

#### **1. 입력 포트 처리**
- 입력 포트의 주요 기능은 다음과 같다:
  1. **패킷 검색**: 라우터는 **포워딩 테이블**을 참조하여, 도착한 패킷이 **출력 포트**로 가기 위한 경로를 결정한다.
  2. **포워딩 테이블 관리**:
     - 포워딩 테이블은 라우팅 프로세서에서 계산되거나 갱신된다.
     - SDN 환경에서는 원격 SDN 컨트롤러에서 수신된다.
  3. **병목 현상 방지**:
     - 포워딩 테이블은 각 라인 카드에 복사되어 사용된다.
     - 이를 통해 패킷 단위 검색 시 라우팅 프로세서를 호출하지 않아 중앙 집중식 병목 현상을 피한다.
### 포워딩 테이블 복사본(라인카드) 역할:
라우터의 라인 카드에 저장된 포워딩 테이블 복사본은 자주 참조되는 데이터를 빠르게 사용하기 위해 저장해 놓은 데이터이다.    
입력 포트에서 들어오는 패킷의 목적지 주소를 빠르게 검색하여 경로를 결정한다.      
- 병목 현상 방지:      
모든 포워딩 요청을 라우팅 프로세서에 보내면 성능이 저하될 수 있다.    
각 라인 카드가 독립적으로 포워딩 테이블 복사본을 참조하므로, 중앙 처리 없이 빠르게 결정을 내릴 수 있다.    
이는 캐시가 CPU 접근을 줄이고 성능을 높이는 원리와 유사하다.    
- 데이터 일관성 관리:    
라우팅 프로세서가 포워딩 테이블을 계산하거나 업데이트하면, 각 라인 카드에 복사본이 전달된다.   
이 과정은 캐시의 데이터 동기화와 비슷하다.    

---

#### **2. 목적지 주소 범위 포워딩 테이블**
- **문제점**:
  - 32비트 IP 주소의 모든 가능한 목적지 주소를 고려하면 40억 개 이상의 엔트리가 필요하다.
  - 이는 비효율적이므로 **목적지 주소 범위**나 **프리픽스** 방식을 사용한다.

---

#### **3. 프리픽스 기반 포워딩 테이블**
- **프리픽스(prefix)**:  
  목적지 주소의 일부 비트를 사용하여 라우터가 출력 포트를 결정한다.
- **동작 방식**:
  1. 패킷의 목적지 주소와 테이블의 엔트리를 매칭한다.
  2. 최장 프리픽스 매치 규칙(Longest Prefix Matching Rule)을 사용:
     - 테이블에서 가장 긴 매치가 되는 프리픽스를 찾아 출력 포트를 결정한다.
  3. 예시:
     - 패킷의 목적지 주소가 `11001000 00010111 00010110 10100001`이면, 앞 21비트가 테이블의 첫 번째 엔트리와 매치되므로 **링크 인터페이스 0**으로 보낸다.
     - 만약 여러 엔트리가 매치된다면 가장 긴 프리픽스를 선택한다.

---

#### **4. 빠른 검색 기술**
- 포워딩 테이블 검색은 **나노초 단위**로 이루어져야 하므로 고속 메모리와 기술이 필요하다.
- **사용되는 메모리 및 기술**:
  1. **SRAM**: 빠른 검색 속도를 제공하는 메모리.
  2. TCAM (Ternary Content Addressable Memory): 여러 엔트리와의 비교를 동시에 수행하는 고속 검색 메모리.

---

#### **5. 스위치 구조로 패킷 전달**
- 검색을 통해 패킷의 출력 포트가 결정되면 패킷은 스위치 구조로 전달된다.
- 일부 경우에는 스위치 구조가 바쁘거나 다른 패킷을 처리 중일 때, 패킷의 전달이 **일시적으로 차단**될 수 있다.
- 패킷 차단, 큐잉, 스케줄링에 대한 자세한 내용은 이후 절에서 다룬다.

---

### **요약**
- 입력 포트는 패킷을 수신하고 **포워딩 테이블**을 참조하여 출력 포트를 결정한다.
- 목적지 주소의 **프리픽스 매칭**을 통해 최적의 경로를 선택하며, **최장 프리픽스 매치 규칙**이 적용된다.
- 고속 검색을 위해 SRAM, TCAM과 같은 메모리 기술이 사용되며, 패킷은 스위치 구조를 통해 출력 포트로 전달된다.  
- 병목 현상을 방지하기 위해 각 라인 카드에 포워딩 테이블 복사본이 존재한다.

## 4.2.2 스위칭
### **스위치 구조와 스위칭 방법**

스위치 구조는 라우터에서 **패킷을 입력 포트에서 출력 포트로 전달하는 핵심 역할**을 수행한다. 아래는 스위치 구조의 주요 스위칭 방법을 정리한 내용이다.

---

### **1. 메모리를 통한 교환**

#### **동작 원리**
- 입력 포트와 출력 포트 간의 패킷 전달이 **중앙 메모리**를 통해 이루어진다.
- 초기 라우터에서 사용된 방식으로, 입력 포트와 출력 포트는 **I/O 장치**처럼 작동한다.

#### **패킷 전달 과정**
1. 패킷이 입력 포트에 도착하면, **라우팅 프로세서**에 인터럽트를 보낸다.
2. 라우팅 프로세서가 패킷을 **메모리로 복사**한다.
3. 포워딩 테이블을 참조하여 출력 포트를 결정하고, 패킷을 **출력 포트의 버퍼**로 복사한다.
4. 출력 포트는 패킷을 출력 링크로 전송한다.

#### **제약**
- **메모리 대역폭이 B인 경우**, 읽기와 쓰기가 모두 필요하므로 처리량은 **최대 B/2**에 불과하다.
- 메모리 작업이 병렬로 수행되지 않아, 동시에 여러 패킷을 처리할 수 없다.

---

### **2. 버스를 통한 교환**

#### **동작 원리**
- 패킷이 **공유 버스**를 통해 입력 포트에서 출력 포트로 직접 전달된다.
- 라우팅 프로세서를 거치지 않아 처리 속도가 향상된다.

#### **패킷 전달 과정**
1. 입력 포트는 패킷에 레이블(출력 포트 정보)을 추가한다.
2. 패킷은 **공유 버스**를 통해 전송된다.
3. 모든 출력 포트가 패킷을 수신하지만, **레이블이 매칭되는 출력 포트**만 패킷을 유지한다.
4. 출력 포트는 레이블을 제거하고 패킷을 출력 링크로 전송한다.

#### **제약**
- 모든 패킷이 **하나의 버스**를 공유하므로, 한 번에 하나의 패킷만 버스를 통과할 수 있다.
- **버스 속도**가 라우터의 처리량을 제한한다.

---

### **3. 상호 연결 네트워크를 통한 교환**

#### **동작 원리**
- **크로스바 스위치**와 같은 상호 연결 네트워크를 사용하여 입력 포트와 출력 포트를 연결한다.
- 여러 패킷을 병렬로 전달할 수 있어 대규모 네트워크 환경에 적합하다.

#### **구조**
- **N개의 입력 포트**와 **N개의 출력 포트**를 연결하는 **2N 개의 버스**로 구성된다.
- 각 입력 포트와 출력 포트는 **스위치 컨트롤러**에 의해 연결된다.

#### **특징**
- 병렬 처리가 가능하여 여러 패킷이 동시에 전달될 수 있다.
- 예: 입력 포트 A → 출력 포트 X, 입력 포트 B → 출력 포트 Y로 동시에 전송 가능.

#### **제약**
- **출력 포트 충돌**:
  - 여러 입력 포트가 동일한 출력 포트를 향해 패킷을 전송하려는 경우, 하나의 패킷만 전송되고 나머지는 대기해야 한다.
- **다단계 스위치**:
  - 충돌 문제를 해결하기 위해 **다단계 스위칭 요소**를 사용하여 충돌을 줄인다.

---

### **스위칭 방식 비교**

| **스위칭 방식**      | **장점**                                      | **단점**                                     |
|---------------------|---------------------------------------------|--------------------------------------------|
| **메모리를 통한 교환** | 단순한 구조, 소형 라우터에 적합                | 메모리 대역폭 제한(B/2), 병렬 처리 불가능     |
| **버스를 통한 교환**   | 라우팅 프로세서의 직접적 개입 없이 전송 가능(라우팅 프로세서의 간접 개입으로 효율적 데이터 전송 가능)       | 버스 속도에 의해 처리량 제한, 병렬 처리 불가   |
| **상호 연결 네트워크** | 병렬 처리 가능, 대규모 라우터에 적합            | 출력 포트 충돌 발생 가능, 복잡한 설계 필요     |


| **스위칭 방식**          | **병렬 처리 가능 여부** | **이유**                                                                 |
|--------------------------|-----------------------|------------------------------------------------------------------------|
| **메모리를 통한 교환**    | 불가능                | 메모리를 공유하므로 대역폭(B) 제한으로 한 번에 하나의 데이터만 처리 가능.       |
| **버스를 통한 교환**      | 불가능                | 단일 버스를 공유하므로 동시에 하나의 전송만 가능, 병렬 데이터 처리가 불가.       |
| **상호 연결 네트워크**    | 가능                  | 독립된 경로를 통해 다수의 입력-출력 연결을 동시에 처리할 수 있음.                |





---

### **요약**
1. **메모리를 통한 교환**:
   - 중앙 메모리를 통해 패킷을 전달하며, 초기 라우터에서 주로 사용되었다.
   - 처리 속도는 메모리 대역폭의 영향을 받으며 병렬 처리가 어렵다.

2. **버스를 통한 교환**:
   - 공유 버스를 사용하여 입력 포트가 직접 출력 포트로 데이터를 전송한다.
   - 처리 속도는 버스 속도에 의해 제한된다.

3. **상호 연결 네트워크**:
   - 크로스바 스위치 구조를 사용하여 병렬 처리를 지원하며 대규모 라우터에 적합하다.
   - 충돌 문제를 해결하기 위해 다단계 스위치 구조를 사용하는 경우도 있다.

스위치 구조는 라우터의 성능과 확장성을 결정하는 핵심 요소로, 네트워크의 규모와 요구에 따라 적합한 방식을 선택해야 한다.


## **4.2.3 출력 포트 처리**

---

### **출력 포트 처리의 역할**
출력 포트는 **스위치 구조에서 전달된 패킷을 처리하고 출력 링크로 전송**하는 역할을 한다.  
이를 위해 다음과 같은 작업을 수행한다:
1. **패킷 선택 및 큐 제거**: 전송할 패킷을 선택하고 큐에서 제거한다.
2. **링크 계층 및 물리 계층 처리**: 출력 링크로 전송하기 위해 패킷을 적절한 형태로 변환한다.

---

### **큐잉(Queuing)이란?**
- **큐잉**은 패킷이 출력 링크를 통해 즉시 전송되지 못할 경우 대기열(queue)에 저장되는 현상을 말한다.
- 큐는 **입력 포트**와 **출력 포트**에서 형성될 수 있다.
- 큐의 형성과 크기는 **트래픽 부하, 스위치 구조의 처리 속도, 출력 링크 속도**에 따라 달라진다.

---

### 1. 입력 큐잉 (Input Queuing)

#### **동작 원리**
- 스위치 구조가 충분히 빠르지 못하거나, 동일한 출력 포트를 향하는 패킷이 많을 경우 입력 포트에서 큐가 형성된다.
- **FCFS(First-Come-First-Served)** 방식으로 패킷은 입력 큐에서 출력 큐로 이동한다.

#### HOL(Head-of-the-Line) 차단
- 입력 큐에서 **앞쪽 패킷**이 다른 입력큐와 동일한 출력 포트를 기다리고 있을 경우, 뒤쪽 패킷은 다른 출력포트로 간다해도 대기해야한다!    
- 결과적으로 **출력 포트가 다른 패킷도 대기**해야 하므로 스위치 구조의 병목 현상이 발생한다.
- 다중큐구조, 빠른 스위치구조, 우선순위기반 스케쥴링 등으로 해결가능!
---

### 2. 출력 큐잉 (Output Queuing)

#### **동작 원리**
- 출력 포트의 큐는 스위치 구조가 매우 빠르더라도 출력 링크가 처리 속도를 따라가지 못할 경우 형성된다.
- 예를 들어:
  - 입력 포트와 출력 포트가 각각 **N개**, 각 링크 속도가 **R**일 때, 출력 포트는 **N개의 패킷**을 출력 링크로 보내야 한다.
  - 출력 링크는 **한 번에 하나의 패킷**만 전송할 수 있으므로 나머지 패킷은 출력 큐에서 대기하게 된다.

#### **문제점**
- 출력 큐에 패킷이 계속 쌓이면 **메모리가 부족**해질 수 있다.
- 새로운 패킷을 저장할 공간이 없을 경우:
  - 도착한 패킷을 삭제하거나,
  - 기존 큐에 있는 패킷을 삭제하여 공간을 확보해야 한다.

---

### **3. 버퍼 크기와 큐잉 지연**
- 버퍼 크기(B)는 패킷 손실과 지연에 큰 영향을 미친다.
  - **버퍼 크기 증가**: 패킷 손실률 감소.
  - **버퍼 크기 감소**: 종단 간 지연 단축.
- **버퍼 크기 계산**:
  - 전통적으로 **B = RTT × C** (왕복 시간 × 링크 용량)가 적합하다고 여겨졌다.
  - 최근 연구에 따르면, **B = RTT × C / √N** (N: 독립적인 TCP 흐름 수)이 더 적합하다고 제안되었다.

---

### 4. 버퍼블로트(Bufferbloat)
- **버퍼블로트**는 지나치게 큰 버퍼로 인해 발생하는 **지속적인 큐잉 지연 현상**이다.
- 예: 게임 중 패킷 손실은 없지만 큐잉 지연으로 인해 반응 속도가 느려지는 경우.
- **해결 방법**:
  - AQM(Active Queue Management) 메커니즘을 도입하여 큐의 크기를 동적으로 조정.

---

### **출력 포트 처리와 큐잉 방식 비교**

| **항목**          | **입력 큐잉**                                 | **출력 큐잉**                                 |
|-------------------|----------------------------------------------|----------------------------------------------|
| **형성 위치**     | 입력 포트                                    | 출력 포트                                    |
| **형성 원인**     | 스위치 구조의 속도가 느리거나 충돌 발생       | 출력 링크의 속도가 스위치 구조 처리량을 따라가지 못함 |
| **HOL 차단**      | 발생 (큐 앞쪽의 패킷이 뒤쪽 패킷의 이동을 막음) | 없음                                         |
| **해결 방안**     | 더 빠른 스위치 구조 사용                     | 출력 링크 용량 증대, AQM 도입                 |

---

### **요약**
1. **출력 포트 처리**:
   - 스위치 구조에서 전달된 패킷을 출력 큐에 저장하고 출력 링크로 전송한다.
   - 큐에서 대기 중인 패킷 중 하나를 선택하여 전송하며, 큐잉 지연을 최소화하기 위한 관리가 필요하다.

2. **큐잉의 문제**:
   - 입력 포트에서는 **HOL 차단**이, 출력 포트에서는 **버퍼 부족**과 **패킷 손실** 문제가 발생할 수 있다.

3. **버퍼 크기와 지연**:
   - 큰 버퍼는 패킷 손실을 줄이지만 지연을 늘린다.
   - 적절한 버퍼 크기 설정과 AQM 같은 메커니즘이 필요하다.

4. **버퍼블로트**:
   - 큰 큐로 인해 발생하는 지속적인 지연 현상으로, 네트워크 성능에 악영향을 미친다.
   - 이를 해결하기 위해 적응형 큐 관리 기술이 도입되고 있다.


## **4.2.5 패킷 스케줄링**

패킷 스케줄링은 **출력 큐에 대기 중인 패킷을 어떤 순서로 전송할지를 결정하는 메커니즘**이다.
 다양한 스케줄링 방법은 네트워크 트래픽의 우선순위를 정하고, 자원을 효율적으로 분배하여 네트워크 성능을 최적화한다.

---

### 1. FIFO(First-In-First-Out)
#### **동작 원리**
- 패킷은 **도착 순서대로 전송**된다.
- 가장 단순한 큐잉 방식으로, 도착 순서(FIFO)와 동일한 순서로 패킷이 전송된다.

#### **패킷 손실 처리**
- 출력 링크가 이미 다른 패킷을 전송 중이고 큐가 가득 찬 경우:
  - 새로운 패킷을 **버리거나**, 기존 큐에서 **낮은 우선순위의 패킷을 제거**하여 공간을 확보한다.

#### **장점**
- 구현이 간단하다.
- 공정한 방식처럼 보인다.

#### **단점**
- **우선순위 처리 불가**: 긴급하거나 중요한 트래픽도 순서를 무조건 기다려야 한다.

---

### **2. 우선순위 큐잉**
#### **동작 원리**
- 패킷을 **우선순위 클래스로 분류**하고, 높은 우선순위의 패킷을 먼저 전송한다.
- 같은 우선순위의 패킷은 FIFO 방식으로 처리된다.

#### **특징**
- 네트워크 관리자가 우선순위를 설정할 수 있다.
  - 예: **관리 트래픽**이 **사용자 트래픽**보다 우선 처리.
- **비선점형 동작**:
  - 전송이 시작된 패킷은 중단되지 않고 끝까지 전송된다.
  - 높은 우선순위의 패킷이라도 현재 전송 중인 패킷이 끝나야 전송이 시작된다.

#### **장점**
- 중요한 트래픽을 우선 처리하여 서비스 품질(QoS)을 보장한다.

#### **단점**
- 낮은 우선순위의 패킷이 계속 대기 상태에 머물러 전송되지 못할 수 있다(**기아 상태 발생**).

---

### **3. 라운드 로빈 (Round Robin)**
#### **동작 원리**
- 패킷을 여러 **클래스**로 분류하고, **각 클래스에 번갈아가며 서비스를 제공**한다.
- 엄격한 우선순위를 적용하지 않아 공정한 처리 방식이다.

#### **특징**
- **작업 보존 큐잉**: 클래스에 대기 중인 패킷이 없다면, 바로 다음 클래스를 검사하여 링크가 유휴 상태가 되지 않도록 한다.

#### **장점**
- 공정한 자원 분배로 **모든 클래스에 일정 수준의 처리율을 보장**한다.
- 기아 상태가 발생하지 않는다.

#### **단점**
- 특정 클래스의 긴급 트래픽을 즉시 처리하지 못할 수 있다.

---

### **4. WFQ(Weighted Fair Queueing)**
#### **동작 원리**
- **라운드 로빈의 일반화된 형태**로, 각 클래스에 가중치(weight)를 할당한다.
- 클래스 i는 **w(i) / ∑w(i)** 만큼의 서비스 시간을 보장받는다.

#### **특징**
- **작업 보존 큐잉**을 따르며, 라운드 로빈처럼 순환적으로 패킷을 처리한다.
- 각 클래스의 가중치에 따라 **출력 링크의 처리율**이 결정된다.
  - 클래스 i의 최소 처리율 = **R × w(i) / ∑w(i)**  
    (R: 출력 링크의 전송 속도)

#### **장점**
- 클래스 간 자원을 **가중치 기반으로 동적 분배**할 수 있다.
- 중요한 클래스에 더 많은 자원을 할당 가능하다.

#### **단점**
- 설정된 가중치에 따라 특정 클래스의 패킷이 더 많이 처리되므로, 공정성 면에서 논란이 있을 수 있다.

---

### **스케줄링 방식 비교**

| **방식**          | **동작 원리**                             | **장점**                              | **단점**                            |
|-------------------|------------------------------------------|--------------------------------------|------------------------------------|
| **FIFO**          | 도착 순서대로 전송                        | 구현이 간단                           | 우선순위 처리 불가                  |
| **우선순위 큐잉** | 높은 우선순위 클래스부터 전송               | 중요한 트래픽 우선 처리 가능           | 낮은 우선순위 패킷의 기아 상태 발생 |
| **라운드 로빈**   | 각 클래스에 순차적으로 서비스를 제공        | 공정한 처리                           | 긴급 트래픽에 대한 대응 부족         |
| **WFQ**           | 클래스에 가중치를 할당하여 자원 분배        | 가중치 기반 자원 분배, QoS 보장        | 가중치 설정에 따른 논란             |

---

### **요약**
1. **FIFO**: 도착 순서대로 처리하며, 구현이 단순하지만 우선순위를 고려하지 않는다.
2. **우선순위 큐잉**: 중요한 트래픽을 우선 처리하지만 낮은 우선순위 패킷의 대기 시간이 길어질 수 있다.
3. **라운드 로빈**: 모든 클래스에 공정하게 서비스를 제공하지만, 긴급 트래픽에 적합하지 않다.
4. **WFQ**: 가중치를 활용해 클래스별로 자원을 차등 분배하며 QoS를 보장한다.(예를들어 가중치 높은건 2배로 자원 할당해서 처리함)


### 우선순위 큐잉(Priority Queuing) vs WFQ(Weighted Fair Queueing)

| **특징**              |우선순위 큐잉(Priority Queuing)                               | WFQ(Weighted Fair Queueing)                               |
|-----------------------|-----------------------------------------------------------------|-------------------------------------------------------------|
| **처리 순서**         | 높은 우선순위 클래스의 패킷을 먼저 처리                            | 모든 클래스가 가중치에 따라 **공정하게 처리**                  |
| **긴급 트래픽 처리**  | 긴급 트래픽(높은 우선순위 클래스)을 즉시 처리                       | 긴급 트래픽도 **가중치 비율**에 따라 처리                     |
| **낮은 우선순위 처리**| 낮은 우선순위 클래스는 **기아 상태**에 빠질 가능성 있음              | 낮은 우선순위 클래스도 일정 수준의 **처리량 보장**             |
| **자원 분배 방식**    | **우선순위 기반** (가중치 사용하지 않음)                           | **가중치 기반** (가중치 비율에 따라 자원 분배)                 |
| **공정성**            | 공정하지 않음 (높은 우선순위가 모든 자원 독점 가능)                | **공정성 보장** (모든 클래스가 가중치에 따른 전송 기회 확보)    |
| **작업 보존 큐잉**     | 적용되지 않음                                                   | 적용됨 (대기 중인 패킷이 없으면 즉시 다음 클래스를 처리)        |
| **적용 사례**         | 긴급 트래픽이 중요한 환경 (예: 제어 트래픽, 네트워크 관리 패킷)      | **QoS 보장**이 중요한 환경 (예: 동영상 스트리밍, VoIP 등)       |
| **구현 복잡도**       | 상대적으로 간단                                                  | 상대적으로 복잡 (가중치 설정 필요)                            |
| **장점**              | - 긴급 트래픽을 **최우선 처리** 가능<br>- 네트워크 안정성 향상      | - 모든 클래스에 공정한 자원 분배<br>- QoS와 최소 처리율 보장 가능 |
| **단점**              | - 낮은 우선순위 클래스의 **기아 상태** 발생 가능                  | - 긴급 트래픽에 즉각 대응 어려움<br>- 가중치 설정이 복잡할 수 있음 |

---

### **요약**
- 우선순위 큐잉(Priority Queuing):  
  - 높은 우선순위 트래픽을 빠르게 처리하는 데 유리하지만, 낮은 우선순위 트래픽이 무시될 수 있다.
  
- WFQ(Weighted Fair Queueing):  
  - 공정한 자원 분배와 QoS를 보장하지만, 긴급 트래픽 처리 속도는 우선순위 큐잉보다 느릴 수 있다.

네트워크 환경에 따라 **긴급성**이 중요한 경우에는 우선순위 큐잉을, **공정성과 QoS 보장**이 중요한 경우에는 WFQ를 선택하는 것이 적합하다.
